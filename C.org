* C

** standard C library
- 
  標準Cライブラリ。
  /libの中のファイルらしい。
  linuxで普通使われているlibcはGNU libc(glibc)。
  Unix系の場合/usr/includeあたりにある場合が多い。

*** assert.h

*** complex.h

*** ctype.h

**** isalnum
- 
  半角の英字か数字なら0以外（真）を返す。それ以外は0を返す。

- def
  #include <ctype.h>
  int isalnum(int ch);

**** isalpha
- 
  引数chが半角英字なら0以外（真）を、それ以外は0を返す。

- def
  #include <ctype.h>
  int isalpha(int ch);


*** error.h

*** float.h

*** limits.h

*** locale.h

*** math.h

*** setjmp.h

*** signal.h

*** stdarg.h

*** stddef.h

*** stdio.h
- 概要
  ストリームおよびファイルの操作に関する型・マクロ・関数の宣言定義
**** fopen(3)
- 
  システムコールのopen()に対応するAPI。

- def
  #inculde <stdio.h>
  FILE *fopen(const char *path, const char *mode);

- argument
  mode:ストリームの性質を指定する。
  |------+-------------------------------+--------------------------------------------------------------|
  | 値   | 対応するopen(2)のmode         | 意味                                                         |
  |------+-------------------------------+--------------------------------------------------------------|
  | "r"  | O_RDONLY                      | 読込み専用。ファイルの存在が前提。                           |
  | "w"  | O_WRONLY ^ O_CREAT ^ O_TRUNC  | 書込み専用。存在しなければ作成。存在したら新たに書込み       |
  | "a"  | O_WRONLY ^ O_CREAT ^ O_APPEND | 追加書込み専用。存在しなければ作成。存在したら末尾に書込む。 |
  | "r+" | O_RDWR                        | 読み書き両用。ファイルの存在が前提。                         |
  | "w+" | O_RDWR ^ O_CREAT ^ O_TRUNC    | 読み書き両用。存在しなければ作成。存在したら新たに書込み。   |
  | "a+" | O_RDWR ^ O_CREAT ^ O_APPEND   | 読み書き両用。存在しなければ作成。存在したら末尾に書込む。   |
  |------+-------------------------------+--------------------------------------------------------------|

- return
  失敗した場合はNULLを返し、原因を表す定数をerrnoにセットする。

**** fclose(3)
- 
  システムコールのclose()に対応する。

- def
  #include <stdio.h>
  int fclose(FILE *stream);

- return
  失敗した場合は定数EOFを返す。
  EOFはstdio.hで定義されるが、普通は-1。

**** fgetc(3), fputc(3)
- 
  バイト単位の入出力API

- def
  include <stdio.h>
  int fgetc(FILE *stream);
  int fputc(int c, FILE *stream);

- fgetc
  streamから1バイト読み込んで返す。
  ストリームが終了した場合はEOF(マクロ、普通は-1)を返す。
- fputc
  streamにバイトcを書込む。
  fgetcした値をそのままfputcできるよう、引数のcはcharでなくint。

**** getc(3), putc(3)
- 
  マクロとして定義されたAPI。
  速度のため定義されているが、最近の環境ではfgetc/fputcと対して変わらない。

- def
  #include <stdio.h>
  int getc(FILE *stream);
  int putc(int c, FILE *stream);

**** getchar(3), putchar(3)
- 
  入力元・出力先が固定されているバイト単位の入出力API。
  getchar()はgetc(stdin), putchar(c)はputchar(c, stdout)と同じ意味。

- def
  #include <stdio.h>
  int getchar(void);
  int putchar(int c);

**** ungetc(3)
- 
  バイト単位で値をバッファに戻す。
  読込んだストリームを１つ戻すことができる。

- def
  #include <stdio.h>
  int ungetc(int c, FILE *stream);


**** fgets(3)
- 
  行単位の入力API
  streamから一行読み込んでバッファbufに格納する。
  ただし最大でもsize-1バイトまでしか読み込まない(最後に\0がつくため)。

- def
  #include <stdio.h>
  char *fgets(char *buf, int size, FILE *stream);

- return
  正常に読み込むか、size-1バイト読み込んだ場合はbufを返す。
  一文字も読まずにEOFにあたった場合はNULLを返す。

**** gets(3)
- 
  fgets(3)と類似機能で、1行を取得するが、
  バッファサイズを示す引数がなく、バッファオーバーフローが起こる可能性があるため、
  この関数は使ってはいけない。

- def
  #include <stdio.h>
  char *gets(char *buf);

**** fputs(3)
- 
  文字列bufをstreamに出力する。

- def
  #include <stdio.h>
  int fputs(const char *buf, FILE *stream);

- return
  問題なく出力できた場合は0以上の数字を返す。
  全てのバイト列を書き終わったか、問題が起きた場合はEOFを返す。
  errnoにも値がセットされるが、ストリームが終了した場合と区別するため、
  あらかじめerrnoを0に設定しておく必要がある。

**** puts(3)
- 
  bufを標準出力に出力後、'\n'を出力する。
  fputs(3)との違いは、出力先が標準出力固定の点と、末尾に'\n'が入る点。

- def
  #include <stdio.h>
  int puts(const char *buf);

**** printf(3), fprintf(3)
- 
  fmtで指定した体裁にしたがって後続の引数をフォーマットした文字列を出力する。
  printf(3)は標準出力固定、fprintf(3)はstreamに出力する。

- def
  #include <stdio.h>
  int printf(const char *fmt, ...);
  int fprintf(FILE *stream, const char *fmt, ...);

- 型指定子
  |------+------------------------------------------------|
  | 文字 | 出力                                           |
  |------+------------------------------------------------|
  | c    | unsigned char型の値を文字として出力            |
  | s    | unsigned char*型が示す値を文字列として出力     |
  | d, i | 整数型の値を10進数で出力                       |
  | u    | 符号なし整数型の値を10進表記で出力             |
  | o    | 符号なし整数型の値を8進表記で出力              |
  | x, X | 符号なし整数型の値を16進表記で出力             |
  | f, F | 浮動小数点数型の値を小数点表現(XX.XXXX)で出力  |
  | e, E | 浮動小数点数型の値を「e表記」(XX.XXe+XX)で出力 |
  | g, G | %f(F)と%e(E)の短い方                           |
  | p    | ポインタを16進表記で出力                       |
  |------+------------------------------------------------|

  - X, F, E
    出力するアルファベットが大文字になる。
    %x, 77 -> 4d, %X, 77 -> 4D
  - h, l
    short, long型を取得する場合につける。
    %lxで、long型を16進出力できる。
  - 桁数
    %と型指定子の間に数字を挟む。
    %10dなど。
  - 左詰め
    マイナスを前置する。
    %-5sなど。
  - 0埋め
    0を前置すると空いた部分が0で埋められる。
    %010x, 7 -> 000000004d

- 問題
  標準入力から1行取得してそのままprintf()した場合、%が入っていた場合に問題が起こる可能性あり。
  下記bufに%が入っていた場合に問題発生する。
  ex) char buf[1024];
      fgets(buf, sizeof buf, stdin);
      printf(buf);

**** scanf(3)
- 
  フォーマットを指定して入力できる。
  ただし、潜在的にgets()と同様バッファオーバーフローを起こす危険がある。
  ex) scanf("%d", &n);
  また、%s指定した場合も、最初のホワイトスペース(tab, space, 改行)にぶつかった時点で読み込みをやめるので、
  使い方が難しく、gets()が使われる場合が多い。

**** fread(3)
- 
  streamより、(size * nmemb)バイト読み込み、bufに格納する。
  失敗したか、読みきる前にEOFに到達した場合はnmembより小さい値を返す。
  '\0'を期待しないので、バッファ末尾に'\0'は書き込まない。

- def
  #include <stdio.h>
  size_t fread(void *buf, size_t size, size_t nmemb, FILE *stream);

**** fwrite(3)
- 
  (size * nmemb)バイト分のバイト列をbufからstreamに書き込む。
  成功したらnmembを返す。
  失敗したらnmembより小さい値を返し、errnoをセットする。

- def
  #include <stdio.h>
  size_t fwrite(const void *buf, size_t size, size_t nmemb, FILE *stream);


**** fseek(3), fseeko(3)
- 
  lseek()システムコールに対応する関数。
  streamのファイルオフセットを、whenceとoffsetで示される位置に移動する。
  whenceはlseek()と同じ。
  long型で表せる限度が2GBなので、fseeko()が存在する。
  off_tはデフォルトでlongだが、"#define _FILE_OFFSET_BITS 64"とすることで64ビット符号付整数型となる。

- def
  #include <stdio.h>
  int fseek(FILE *stream, long offset, int whence);
  int fseeko(FILE *stream, off_t offset, int whence);

- whence
  SEEK_SET:offsetに移動（起点はファイル先頭）
  SEEK_CUR:現在のファイルオフセット+offsetに移動
  SEEK_END:ファイル末尾+offsetに移動

**** ftell(3), ftello(3)
- 
  streamのファイルオフセットの値を返す。

- def
  #include <stdio.h>
  long ftell(FILE *stream);
  off_t ftello(FILE *stream);

**** rewind(3)
- 
  streamのファイルオフセットをファイルの先頭に戻す。
- def
  #include <stdio.h>
  void rewind(FILE *stream);

**** fileno(3)
- 
  streamがラップしているファイルディスクリプタを返す。

- def
  #include <stdio.h>
  int flieno(FILE *stream);

**** fdopen(3)
- 
  fdをラップするFILE型の値を新しく作成してポインタを返す。
  失敗したらNULLを返す。
  modeはfopen()の第2引数と同じ。

- def
  #include <stdio.h>
  FILE *fdopen(int fd, const char *mode);


**** fflush(3)
- 
  streamがバッファリングしている内容を即座にwrite()する。
  成功したら0を返す。失敗したらEOFを返してerrnoをセットする。
  改行せずに文字列を端末に出力したいときなどに使う。

- def
  #include <stdio.h>
  int fflush(FILE *stream);

**** setvbuf(3)
- 
  用意したバッファをstdioに強制的に使わせることができる。


**** feof(3)
- 
  直前の読み込み作業でstreamがEOFに達していたら真を返す。
  この関数は必要になることはないし、初心者は使い方を間違えるため、
  使うな、とのこと。

- def
  #include <stdio.h>
  int feof(FILE *stream);

**** ferror(3)
- 
  直前の入出力操作でエラーが起きていたら真を返す。
  ほとんど使わない。

- def
  #include <stdio.h>
  int ferror(FILE *steram);

**** clearerr(3)
- 
  streamのエラーフラグとEOFフラグをクリアする。
  stdioのルーチンはread()が一度でもEOFを返すとFILEにEOFフラグをセットし、
  それ以降はread()を呼ばなくなってしまうので、clearerr()を使うとEOFフラグをクリアできる。

- def
  #include <stdio.h>
  void clearerr(FILE *stream);

**** perror(3)
- def
  #include <stdio.h>

  void perror(const char *s);

- argument
  s:出力用文字列
- 
  "s:"につづきエラーメッセージを出力する。

**** strerror()
- def
  #include <string.h>
  
  char *strerror(int errnum);

- argument
  errnum:errnoを指定する
- 
  errnoの値errnumに対応したエラーメッセージを返す

*** stdlib.h
- 概要
  一般ユーティリティに関する型・マクロ・関数の宣言定義


**** exit()
- 
  プログラムを終了する関数


**** atoi(3), atol(3)
- 
  整数表現を含む文字列strから対応する整数値を得る。

- def
  #include <stdilb.h>
  int atoi(const char *str);
  long atol(const char *str);

- return
  整数を返す。
  整数が含まれていない場合やエラーが発生した場合は0を返す。

**** strtol()
**** strtoll()
**** strtod()

*** string.h

**** strcpy()

**** strcat()

**** strcmp()

**** strlen()
*** time.h


** library
*** conio.h

**** getche()
- 
  getchar()をインタラクティブに処理したい場合に使う。

**** cprintf()
- 
  printf()関数と同様のはたらきだが、改行文字を(\n)を復帰改行に変換しない。

**** cscanf()
- 
  scanf()と同様のはたらきをする

*** unistd.h
- 
  Unix Standard Header File

**** getopt(3)
- 
  ショートオプションだけを認識するオプション解析API。
  UNIX系OSに古くから存在する。

- def
  #include <unistd.h>
  int getopt(int argc, char * const argv[], const char *optdecl);
  extern char *optarg;
  extern int optind, opterr, optopt;

- getoptに関連したグローバル変数
  |-------+--------+--------------------------------------------------|
  | 型    | 名前   | 意味                                             |
  |-------+--------+--------------------------------------------------|
  | char* | optarg | 現在処理中のオプションのパラメータ               |
  | int   | optind | 現在処理中のオプションのargvでのインデックス     |
  | int   | optopt | 現在処理中のオプション文字                       |
  | int   | opterr | 真ならばエラー時にgetopt()がメッセージを表示する |
  |-------+--------+--------------------------------------------------|

- return
  オプションがなくなった場合に-1を返す。
  オプションが存在する場合はオプションを返す。

*** getopt.h

**** getopt_long(3)
- 
  glibcらしい。

- def
  #define _GNU_SOURCE
  #include <getopt.h>

  int getopt_long(int argc, char * const argv[],
                  const char *optdecl,
                  const struct option *longoptdecl,
                  int *longindex);

  struct option {
      const char *name;
      int has_arg;
      int *flags;
      int val;
  };

  extern char *optarg;
  extern int optind, opterr, optopt;

- struct option member
  |----------+-------+--------------------------------------------------------------------|
  | メンバ名 | 型    | 値と意味                                                           |
  |----------+-------+--------------------------------------------------------------------|
  | name     | char* | ロングオプション名。"lines" "help"など                             |
  | has_arg  | int   | no_argument(または0) : パラメータを取らない                        |
  |          |       | required_argument(または1) : 必ずパラメータを取る                  |
  |          |       | optional_argument(または2) : パラメータをとるかもしれない          |
  | flags    | int*  | NULL : getopt_long()はvalメンバの値を返す                          |
  |          |       | NULL以外 : getopt_long()は0を返し、*flagsにvalメンバの値を代入する |
  | val      | int   | flagsメンバで指定されたところに返す値                              |
  |----------+-------+--------------------------------------------------------------------|

*** regex.h
**** regex
- 
  libcの正規表現API。
  実際どこにあるのかは知らない。

- def
  #include <sys/types.h>
  #include <regex.h>

  int regcomp(regex_t *reg, const char *pattern, int flags);
  void regfree(regex_t *reg);
  int regexec(const regex_t *reg, const char *string,
              size_t nmatch, regmatch_t pmatch[], int flags);
  size_t regerror(int errcode, const regex_t *reg,
                  char *msgbuf, size_t msgbuf_size);

- 一部説明
  - regcomp
    正規表現パターンpatternを専用のデータ型regex_tに変換する。
    結果は第1引数regに書込まれる。
    regのメモリ領域は割り当ててそのポインタを渡す必要があるが、
    その他に独自に確保した領域をregex_t内部に確保する。
    成功したら0を返し、失敗したらエラーコードを返す。
    regerror()でエラーメッセージに変換できる。
  - regfree
    regcompで独自に確保した領域を解放する。
  - regexec
    実際に文字列のパターンを照合する。
    文字列stringがパターンregに適合するなら0を返す。
    適合しなければ、定数REG_NOMATCHを返す。

*** dirent.h
**** opendir(3)
- 
  pathにあるディレクトリを読み込みのため開く。
  戻り値はDIRという型のポインタで、構造体ストリームを管理するための構造体。

- def
  #include <sys/types.h>
  #include <dirent.h>

  DIR *opendir(const char *path);

**** readdir(3)
- 
  ディレクトリストリームdからエントリを一つ読込み、エントリを返す。。
  struct direntはOSにより異なるが、Linuxにはエントリの名前を表す「char *d_name」が存在する。
  d_nameは普通の文字列なので、printf()やfputs()に渡せる。
  エントリがなくなるか読込みに失敗するとNULLを返す。
  ちなみにシステムコールのreaddirもあるので、"man 3 readdir"と明示する必要あり。

- def
  #include <sys/types.h>
  #include <dirent.h>

  struct dirent *readdir(DIR *d);

**** closedir(3)
- 
  ディレクトリストリームdを閉じる関数。
- def
  #include <sys/types.h>
  #include <dirent.h>
  int closedir(DIR *d);

**** seekdir()
- 
  fseek()に相当するdir操作

**** telldir()
- 
  ftell()に相当するdir操作


** syntax
*** do { ... } while ();

*** break;
*** continue;
*** switch() { case [value]: ... break; ... ; default ... }
*** goto [tag];


** preprocessor

*** #include

*** #define
- #define マクロ名 文字列

*** #if, #else, #elif, #endif

*** #ifdef, #ifndef

*** macro

**** __LINE__
- 
  ソースの行番号を返す

**** __FILE__
- 
  ファイルの名前を表す文字列を定義する。

**** __DATE__
- 
  月/日/年 のフォーマットでシステム日付を返す

**** __TIME__
- 
  プログラムのコンパイルを開始した時間を表す文字列を定義する。

**** __STDC__
- 
  ANSI Cに準拠している場合に1を返す。


** memo

*** ANSI C
- K&R
  K&R Cは1978年に出版された本がもとになったもの。
- ANSI C(C89)
  ANSI Cといえば、89年に規定されたものを言うのが普通(C89)。
  K&Rに曖昧な点があったため、ISOとANSIが規格化を進めた。
- C99
  99年に改訂された企画はC99と呼ぶ。
- C11(C2011)
  2011年の改訂版はC2011(C11)。
*** ファイルディスクリプタとFILE
- 
  FILEは生のストリームにバッファ機能を追加する層で、
  ファイルディスクリプタをラップしている。
  この2つの型を同時に使うと、バッファを介す操作と介さない操作が混在するため、
  出力順がおかしくなる可能性がある。

*** 特殊文字
- 
  |------+---------------+---------------+---------------------------|
  | 数値 | ASCIIでの表記 | C言語での表記 | 意味                      |
  |------+---------------+---------------+---------------------------|
  |    0 | NUL           | '\0'          | 文字列の終端              |
  |    7 | BEL           | '\a'          | ベルを鳴らす              |
  |    8 | BS            | '\b'          | バックスペース(backspace) |
  |    9 | HT            | '\t'          | タブ(holizontal tab)      |
  |   10 | LF            | '\n'          | 改行(line feed)           |
  |   12 | FF            | '\f'          | 改ページ(form feed)       |
  |   13 | CR            | '\r'          | 復帰(carrige return)      |
  |------+---------------+---------------+---------------------------|


*** keyword
- 
  auto, break, case, char, const, continue, default, do,
  double, else, enum, extern, float, for, goto, if,
  int, long, register, return, short, signed, sizeof, static,
  struct, switch, typedef, union, unsigned, void, volatile, while

*** 演算子の優先順位
- 
  |----------+------------|
  | 優先順位 | 演算子     |
  |----------+------------|
  | 高い     | !          |
  |          | > >= < <=  |
  |          | == !=      |
  |          | &&         |
  | 低い     | ll(パイプ) |
  |----------+------------|


*** 基本データ型
- 基本データ型
  char, int, float, double, void
- 型修飾子
  long, short, signed, unsigned

*** suffix
- 
  数値のデフォルトはintとdouble。
  末尾に接尾子をつけることで型を変えられる。
- F float
- L long
- U unsigned
