* Linux
** Linux OS
*** 構成要素

- shell
  bash, ash, csh, tsch, zsh, pdksh, ...
- util-linux
  init, getty, login, reset, fdisk, ...
- procps
  ps, pstree, top, ...
- GNU coreutils
  ls, cat, mkdir, rmdir, cut, chmod, ...
- GNU grep, find, diff
- GNU libc
- libraries 
  ncurses, GDMB, zlib, ...
- development enviroment
  gcc, binutils, make, bison, flex, headerfiles, ...
- X Window System
- GNOME, KDE
(「ふつうのLinux」p.27)

*** アドレス空間の構造

- テキスト領域
  機械語のプログラム
- データ領域
  グローバル変数や関数内のスタティック変数のうち初期化済みのもの、
  文字列リテラルがおかれる。
- BSS領域
  グローバル変数や関数内のスタティック変数のうち初期化が必要ないものがおかれる。
- ヒープ領域
  malloc()が管理する領域
- スタック領域
  関数呼び出しに関連したデータを置くところ。
  関数の引数やローカル変数がおかれる。

*** File
- memo
  以下は広義ではすべてファイル。

- regular file
- directory
- symbolic link
- device file
  - character device file
    プリンタやモデムなど。
    データの読み書きを1バイトずつ行う。
  - block device file
    ハードディスクなど。
    データの読み書きをブロック単位で行うハードウェアを抽象化したもの。
- named pipe
  プロセス間通信に使うファイル。FIFO。
- UNIX domain socket

** Directory Structure
*** / (FHS)
- 
  第一階層、ルートディレクトリ

**** /bin
- 
  シングルユーザモードで必要となる一般ユーザ向け基本コマンドの実行ファイル。
  /usr/binはシングルユーザ以外の一般ユーザ向けコマンド。
  
- 
  必須: 
  cat, chgrp, chmod, chown, cp, date, dd, df, dmesg, echo, false, hostname,
  kill, ln, login, ls, mkdir, mknod, more, mount, mv, ps, pwd, rm, rmdir,
  sed, sh, stty, su, sync, true, unmount, uname

- 
  オプション: 
  csh, ed, tar, cpio, gzip, gunzip, zcat, netstat, ping

**** /boot
- 
  ブートローダ関連のファイル群。カーネルやinitrd。通常別パーティション。
  カーネルは、vmlinuzに格納されている。
  unix -> vmunix（仮想メモリ機構追加） -> vmlinux -> vmlinuz（圧縮）のように変遷した。

**** /dev
- 
  基本デバイス。/dev/null, /dev/consoleなど。
  Linux2.4ではdevfsという仕組みが導入されたが、USBなどと相性が良くなかったため、
  Linux2.6以降はudevという仕組みが使われる。
  defvsはカーネルの一部だが、udevはカーネルの外。
  "ls -l"などのコマンドで確認すると、キャラクタデバイスかブロックデバイスかが確認できる。

**** /etc
- 
  システム全体の固有設定ファイル群。バイナリファイルを置かない。
  fstab, gateway, group, hosts, password, profile, servicesなど。

***** /etc/opt
- 
  /opt/のための設定ファイル群。
***** /etc/X11
- 
  X Window System用の設定ファイル群。
***** /etc/sgml
- 
  sgml設定ファイル群。
***** /etc/xml
- 
  xml設定ファイル群。
***** /etc/init.d
- 
  デーモンを起動するためのファイルが置かれる。
  これらのファイルは起動スクリプトと呼ばれる。
  /etc/rc*.dディレクトリの起動スクリプトの実態はすべて/etc/init.dに格納されている。

**** /home
- 
  ユーザのホームディレクトリ。オプション。

**** /lib
- 
  /bin や /sbin にある実行ファイルの基本となるライブラリ群。

**** /lost+found (FHSの規定にはなし)
- 
  fsckでディスクチェックした際に作られる、破損ファイルの断片を収めるディレクトリ。

**** /media
- 
  CD-ROMなどのリムーバブル媒体マウントポイント。

**** /mnt
- 
  ファイルシステムの一時マウントポイント。

**** /opt
- 
  オプションのアプリケーションソフトウェアのインストール用

**** /proc
- 
  カーネルやプロセスの情報をテキストで示す仮想ファイルシステム。
  procfs(Process File System)のマウントポイント。

**** /root
- 
  rootユーザのホームディレクトリ。オプション。

**** /sbin
- 
  システム管理系コマンドの実行ファイル群。

- 必須:
  shutdown

- オプション:
  fastboot, fasthalt, fdisk, fsck, fsck.*, getty, halt, ifconfig, init,
  mkfs, mkfs.*, mkswap, reboot, route, swapon, swapoff, update

**** /srv
- 
  システムによって提供された(served)固有のデータ

**** /tmp
- 
  一時ファイル置場。リブート時には内容が削除される。
  /var/tmpは消えない。

**** /usr
- 
  ユーザユーティリティとアプリケーションを格納。
  複数のマシンで共有可能なファイルを置き、多くのマシンにマウントして使ったりする。
  共有できないようなファイルはvarにおく。
  "User Services and Routines"の略らしい。

***** /usr/bin
- 
  一般ユーザ向けだが基本的でないコマンド。
  シングルユーザモードには不要なバイナリで、パッケージの追加削除でファイルは増減する。
  ディストリビューションが管理するディレクトリなので、自分でインストールするプログラムは/usr/local/binなどに置く。

***** /usr/include
- 
  標準includeファイル群。C言語で使う標準ヘッダファイル。
  カーネルのヘッダファイルは/usr/include/linuxと/usr/include/asmにある。
  本来は/usr/include/sys以下がカーネル関連だが、
  Linuxはカーネルとlibcで管理者が置が言うため少し変則的なディレクトリ構造になっている。

***** /usr/lib
- 
  /usr/bin や /usr/sbin にある実行ファイルの基本ライブラリ。

***** /usr/sbin
- 
  基本的でない実行ファイル群。ネットワーク用デーモンなど。
  平常時用のシステム管理コマンドやサーバプログラム。

***** /usr/share
- 
  アーキテクチャに依存しない共有データ
  典型的な例はドキュメント。manやinfoなど。

****** /usr/shar/man
- 
  manページを置く。
  roffというテキスト形式で書かれている。

****** /usr/share/info
- 
  infoドキュメントを置く。
  textinfo形式のファイルがinfo直下に並ぶ。

***** /usr/src
- 
  システムで使っているコマンドのソースコードを置く。
  Kernelのソースコードなど。

***** /usr/X11R6
- 
  X Windows System Version 11 Release 6
  下にbinやlibがある。

***** /usr/local
- 
  ホスト固有のローカルデータを格納する。システム管理者が自分でアプリケーションをインストールする。
  構造はほぼ/usrと同じ。

****** /usr/local/bin
- 
  自分でインストールするコマンド等を配置する。

****** /usr/local/games
****** /usr/local/include
****** /usr/local/lib
****** /usr/local/man
- /local/bin用マニュアル
****** /usr/local/sbin
- /sbinと比べて重要でないシステムバイナリを配置する。
  /sbinは緊急時に必要なもの、/usr/sbinは通常運用時。
****** /usr/local/share
- アーキテクチャに依存しないデータを収める。
****** /usr/local/man
******* /usr/local/man/man1
- ユーザプログラム
******* /usr/local/man/man2
- システムコール
******* /usr/local/man/man3
- Cライブラリ関数
******* /usr/local/man/man4
- スペシャル(デバイス)ファイル
******* /usr/local/man/man5
- ファイルフォーマット
******* /usr/local/man/man6
- ゲーム
******* /usr/local/man/man7
- その他
******* /usr/local/man/man8
- システム管理
****** /usr/local/misc
****** /usr/local/src

**** /var
- 
  可変なファイル群。内容が常に変化するようなファイル群を格納する。
  ログ、スプール、一時的な電子メール等。

***** /var/cache
- 
  アプリケーションのキャッシュデータ。
  普通は要領に上限を設けて、古い順に捨てていく。

***** /var/lib
- 
  状態情報。データベース、パッケージングシステムのメタデータなど。

****** /var/lib/misc

***** /var/local
***** /var/lock
- 
  ロックファイル群。使用中リソースを保持するファイル。排他制御を行いたい場合に使用する。
***** /var/log
- 
  各種ログ
***** /var/opt
***** /var/mail
- 
  メール
***** /var/run
- 
  走行中システムに関する情報。現在ログイン中のユーザ、走行中デーモン等。
  "`kill -HUP `cat /var/run/sendmail.pid`"などするとプロセス番号をタイポせずよい。
  PIDファイルともいう。

***** /var/spool
- 
  処理待ちスプール。プリントキュー、未読メールなど。

****** /var/spool/mail
- 
  互換のためのかつてのメールボックス。

***** /var/tmp
- 
  一時ファイル置場。/tmpとは異なり、リブートしても内容が失われない。

**** memo
- ディレクトリの分類
  |----------+----------------------------+---------------------|
  |          | 共有可能                   | 共有不可            |
  |----------+----------------------------+---------------------|
  | 変化せず | /usr, /opt                 | /etc, /boot         |
  |----------+----------------------------+---------------------|
  | 変化する | /var/mail, /var/spool/news | /var/run, /var/lock |
  |----------+----------------------------+---------------------|

*** / (何を参照したかは忘れた。)
    - vmlinuz
        Linux Kernel
    - boot
        - System.map
        - config
        - grub
        - initrd.img
          init ram disk
    - etc
        Setting Files
    - bin
        commands using by system admin and user
    - sbin
        admin tools using by system admin
    - usr
        directory which has data shared by users using the system
        - bin
        - include
        - lib
        - local
            - bin
            - etc
            - games
            - include
            - lib
            - man
            - sbin
            - share
            - src
        - sbin
        - share
    - home
    - var
        variable data
        - tmp
            directory with sticky bit, that makes the files in the directory not able to delete without the owner
        - log,spool
        - mail
        - run
            having PID in text files
        - lock
    - proc
        procfs(Process File System)
        pseudo file system giving system information
        /proc/PID/oom_score, oom_adj <-concerning with OOM Killer(Out Of Memory Killer)
    - sys
        sysfs: devise info, procfs: process and kernel info
    - dev
        deployed device files
    - tmp
        temporary
        deleted when unmounting or rebooting

** System calls
*** read(2)
- def
  #include <unistd.h>
  ssize_t read(int fd, void *buf, size_t bufsize);

- argument
  fd:ファイルディスクリプタの番号
  buf:格納先
  bufsize:最大読込バイト数

- return
  正常終了した場合は読込んだバイト数を返す。
  ファイル終端に達したときは0を、エラーが起きたときは-1を返す。

*** write(2)
- def
  #include <unistd.h>
  ssize_t write(int fd, const void *buf, size_t bufsize)

- argument
  fd:ファイルディスクリプタの番号
  buf:書込元
  bufsize:最大書込サイズ数

- return
  正常終了時は書き込んだバイト数を返す。
  エラー時は-1を返す。

*** open(2)
- def
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <fcntl.h>
  int open(const char *path, int flags);
  int open(const char *path, int flags, mode_t mode);

- argument
  path:openするファイルのパス
  flags:ストリームの性質を表すフラグ
  mode:O_CREATを指定した場合に、新規ファイルのパーミッションを指定する

  - flags 1
    常にどれか一つを指定する
    |----------+--------------|
    | O_RDONLY | 読み取り専用 |
    | O_WRONLY | 書込み専用   |
    | O_RDWR   | 読み書き両用 |
    |----------+--------------|

  - flag 2
    指定しなくても良いし、複数指定しても良い。
    下のもの以外にも色々ある。
    |----------+-----------------------------------------------------------------------------------|
    | O_CREAT  | ファイルが存在しなければ新しいファイルを作る                                      |
    | O_EXCL   | O_CREATとともに指定すると、すでにファイルが存在するときはエラーとなる             |
    | O_TRUNC  | O_CREATとともに指定すると、ファイルが存在するときはまずファイルの長さをゼロにする |
    | O_APPEND | write()が常にファイル末尾に書込まれるよう指定する                                 |
    |----------+-----------------------------------------------------------------------------------|

- return
  ファイルディスクリプタの値を返す

  - ex
    open(file, O_RDWR|O_CREAT|O_TRUNC, 0666)

*** close(2)
- def
  #include <unistd.h>
  int close(int fd);

- argument
  fd:ファイルディスクリプタ

- return
  問題なく閉じられた場合は0, エラーがあった場合は-1を返す。

- ex
  if (close(fd) < 0){
      /* エラー処理 */
  }

*** lseek(2)
- 
  ファイルディスクリプタfd内部のファイルオフセットを指定した位置offsetへ移動する。
  移動方法はwhenceに指定する。

- def
  #include <sys/types.h>
  #include <unistd.h>
  off_t lseek(int fd, off_t offset, int whence);

- argument
  whence:位置の指定方法。
         SEEK_SET:offsetに移動（起点はファイル先頭）
         SEEK_CUR:現在のファイルオフセット+offsetに移動
         SEEK_END:ファイル末尾+offsetに移動

*** dup(2), dup2(2)
- 
  oldfdを複製するシステムコール。
  dup()は使われていない最小のファイルディスクリプタへoldfdを複製してそれを返す。
  dup2()はoldfdをnewfdに複製してそれを返す。
  エラーが起きた場合は-1を返す。
  dupはduplicateから。

- def
  #include <unistd.h>
  int dup(int oldfd);
  int dup2(int oldfd, int newfd);

*** ioctl(2)
- 
  ストリームがつながる先にあるデバイスに特化した操作を全て含めたシステムコール。

- def
  #include <sys.ioctl.h>
  int ioctl(int fd, int request, ...);

- argument
  request:どのような操作をするか定数で指定し、そのrequest特有の引数を第3引数以降に渡す。

*** fcntl(2)
- 
  ファイルディスクリプタ関連の操作をioctlより分離したもの。

- def
  #include <unistd.h>
  #include <fcntl.h>
  int fcntl(int fd, int cmd, ...);

*** mkdir(2)
- 
  ディレクトリpathを作成する。
  成功したら0を返し、失敗したら-1を返してerrnoをセットする。
  第2引数には作成時のパーミッションを指定する。

- def
  #include <sys/stat.h>
  #include <sys/types.h>

  int mkdir(const char *path, mode_t mode);

- error
  - ENOENT
    親ディレクトリがない
  - ENOTDIR
    pathで親ディレクトリに当たる部分がディレクトリでない
  - EEXIST
    pathにすでにファイルやディレクトリが存在する
  - EPERM
    親ディレクトリを変更する権限がない

*** umask(2)
- 
  直前までのumaskの値をmaskに変更し、直前万でのumaskを返す。
- def
  #include <sys/types.h>
  #include <sys/stat.h>
  
  mode_t umask(mode_t mask);

*** rmdir(2)
- 
  ディレクトリpathを削除する。

- def
  #include <unistd.h>
  int rmdir(const char *path);

*** link(2)
- 
  ファイルsrcの実態に新しい名前distをつける。(ハードリンク）
  成功したときは0を返し、失敗したときは-1を返してerrnoをセットする。
  srcとdistは同じファイルシステム上に存在する必要がある。
  また、ディレクトリには使用できない。

- def
  #include <unistd.h>
  int link(const char *src, const char  *dest);

*** symlink(2)
- 
  シンボリックリンクを作成するシステムコール。
  srcを指す新しいシンボリックリンクをdestに作成する。
  成功したら0を、失敗したら-1を返す。
- def
  #include <unistd.h>
  int symlink(const char *src, const char *dest);

*** readlink(2)
- 
  readlinkは、pathの表している名前をbufに格納する。
  ただし、いかなる場合もbufsizeバイトまでしか書込まない。
  また、文字列最後の'\0'は書込まれない。
  成功したらbufに格納したバイト数を返す。失敗したら-1を返してerrnoをセットする。
- def
  #include <unistd.h>
  int readlink(const char *path, char *buf, size_t bufsize);

*** unlink(2)
- 
  名前pathを消す。成功したら0を、失敗したら-1を返す。
  ディレクトリの削除はできない。
- def
  #include <unistd.h>
  int unlink(const char *path);

*** rename(2)
- 
  srcをdestに変更する。
  成功したら0を、失敗したら-1を返してerrnoをセットする。
  ファイルシステムをまたいで移動することはできない。その場合EXDEVがerrnoにセットされる。
- def
  #include <stdio.h>
  int rename(const char *src, const char *dest);

*** stat(2)
- 
  statはpathで表されるエントリの情報を取得し、bufに書き込む。
  lstatもほとんど同じだが、シンボリックリンクの場合にリンクをたどらず自身の情報を返す。
  似たものに、ファイルディスクリプタから同じ情報を得られるfstatもある。
  成功したら0を返し、失敗したら-1を返してerrnoをセットする。

- def
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <unistd.h>

  int stat(const char *path, struct stat *buf);
  int lstat(const char *path, struct stat *buf);

- struct statメンバ
  |-----------+------------+--------------------------------------------|
  | 型        | メンバ名   | 説明                                       |
  |-----------+------------+--------------------------------------------|
  | dev_t     | st_dev     | デバイス番号                               |
  | ino_t     | st_ino     | iノード番号                                |
  | mode_t    | st_mode    | ファイルタイプとパーミッションを含むフラグ |
  | nlink_t   | st_nlink   | リンクカウント                             |
  | uid_t     | st_uid     | 所有ユーザID                               |
  | gid_t     | st_gid     | 所有グループID                             |
  | dev_t     | st_rdev    | デバイスファイルの種別を表す番号           |
  | off_t     | st_size    | ファイルサイズ（バイト単位）               |
  | blksize_t | st_blksize | ファイルのブロックサイズ                   |
  | blkcnt_t  | st_blocks  | フロック数                                 |
  | time_t    | st_atime   | 最終アクセス時刻                           |
  | time_t    | st_mtime   | 最終変更時刻                               |
  | time_t    | st_ctime   | 付帯情報が最後に変更された時期             |
  |-----------+------------+--------------------------------------------|

*** chmod(2)
- 
  pathのモードをmodeに変更する。
  成功したら0を返し、失敗したら-1を返してerrnoをセットする。

- def
  #include <sys/types.h>
  #include <sys/stat.h>
  
  int chmod(const char *path, mode_t mode)

*** chown(2)
- 
  pathの所有ユーザをownerに、所有グループをgroupに変更する。
  ownerはユーザID, groupはグループID。
  どちらかだけを変更したい場合、変更しない値を-1とする。
  lchownは、pathがシンボリックリンクだった場合はシンボリックリンク自体の情報を変更する。
  成功したら0を返す。失敗したら-1を返し、errnoを設定する。
  所有ユーザを変更する場合はスーパーユーザ権限が必要。
  所有グループを変更する場合はファイルの所有ユーゼでかつ自分がgroupに含まれる必要がある。
  スーパーユーザならば任意のグループに変更可能。

- def
  #include <sys/types>
  #include <unistd.h>
  
  int chown(const char *path, uid_t owner, gid_t group);
  int lchown(const char *path, uid_t owner, gid_t group);

*** utime(2)
- 
  pathの最終アクセス時刻(st_atime)と最終更新時刻(st_mtime)を変更する。
  bufがNULLでなければ最終アクセス時効をbuf->actime, 最終更新時刻をbuf->modtimeに変更する。
  bufがNULLなら両方を現在時刻に変更する。
  成功したら0を返し、失敗したら-1を返しerrnoを設定する。

- def
  #include <sys/types.h>
  #include <utime.h>
  
  int utime(const char *path, strut utimbuf *buf);
  
  struct utimbuf {
      time_t actime; /* 最終アクセス時刻 */
      time_t modtime; /* 最終更新時刻 */
  }

*** mmap(2)
- 
  ファイルやデバイスをメモリにマップ/アンマップする
  ファイル記述子fdで指定されたファイルの、オフセットoffsetからlengthバイトの範囲を
  メモリにマップする。
  このとき、なるべくメモリ上のaddrアドレスからはじめるようにマップする。
  実際には関数に対してのヒントでしかなく、通常は0を選択する。
  protは、メモリ保護をどのように行うか指定する。
  flagsは、マップされたオブジェクトのタイプ、マップ時のオプション、
  マップされたページコピーへの変更をそのプロセスだけが行えるのか指定する。

- def
  #include <sys/mman.h>
  void *mmap(void *addr, size_t length, int prot, int flags,
             int fd, off_t offset);
  int munmap(void *addr, size_t length);

- plot
  |------------+--------------|
  | フラグ名   | 内容         |
  |------------+--------------|
  | PROT_EXEC  | 実行可能     |
  | PROT_READ  | 読み込み可能 |
  | PROT_WRITE | 書き込み可能 |
  | PROT_NONE  | アクセス不能 |
  |------------+--------------|

- return
  - mmap
    成功するとマップされた領域へのポインタを返す。
    失敗すると値MAP_FAILED((void *)-1)を返し、errnoがセットされっる。
  - munmap
    成功すると0を返し、失敗すると-1を返しerrnoがセットされる（多くの場合EINVAL）。

*** brk(2)
- 
  物理アドレスが割り当てられていないページに物理アドレスを対応させる。
  malloc(3)やrealloc(3)が使っているシステムコール。
  sbrk(2)というシステムコールもある。

*** fork(2)
- 
  プロセスを複製し、2つのプロセスに分裂させる。
  両方のプロセスでfork()の呼び出しが戻る。
  元から存在しているほうを親プロセス、複製した方を子プロセスという。
  子プロセスでの戻り値は0で、親プロセスの戻り値は子プロセスのプロセスIDとなる。
  失敗した場合は子プロセスは作成されず、親でのみ-1が戻る。

- def
  #include <sys/types.h>
  #include <unistd.h>
  pid_t fork(void);

*** exec(2)
- 
  現在実行してるプロセスが消滅し、自プロセスに新しいプログラムをロードする。
  execは成功すると呼び出しが戻らないので、戻った場合は常に失敗。-1を返してerrnoをセットする。
  - l
    語尾に"l"がつくものは、コマンドライン引数を引数リストとして渡す。
    引数リストの最後はNULLを置かなければならない。
  - v
    コマンドライン引き巣を文字列の配列で渡す。argv[]の最後の要素はNULLにしなければならない。
  - e
    最後の引数として環境変数envpが追加される。
    eがついていないAPIでは、現プロセスの環境変数がそのまま使われる。
  - p
    第1引数programを環境変数PATHから自動で探す。
    pがついていない場合、常にpathを絶対パスまたは相対パスで指定しなければならない。

- def
  #include <unistd.h>

  int execl(const char *path, const char *arg, ... /* NULL */);
  int execlp(const char *program, const char *arg, ... /* NULL */);
  int execle(const char *path, const char *arg, ... /* NULL, */
             char * const envp[]);
  int execv(const char *path, char * const argv[]);
  int execvp(const char *program, char * const argv[]);
  int execve(const char *path, char * const argv[],
             char * const envp[]);

*** wait(2)
- 
  waitは子プロセスのうちどれかひとつが終了するのを待つ。
  waitpidはpidで指定したプロセスが終了するのを待つ。
  statusにNULL以外を指定した場合、そのアドレスに子プロセスの終了ステータスが格納される。

- def
  #include <sys/types.h>
  #include <sys/wait.h>
  
  pid_t wait(int *status);
  pid_t waitpid(pid_t pid, int *status, int options);

- 終了の仕方を調べるマクロ

  |---------------------+----------------------------------------------------|
  | マクロ              | 意味                                               |
  |---------------------+----------------------------------------------------|
  | WIFEXITED(status)   | exitで終了していたら非0、それ以外なら0             |
  | WEXITSTATUS(status) | exitで終了し手いたときに、その終了コードを返す。   |
  | WIFSIGNALED(status) | シグナルで終了したら非0、それ以外なら0             |
  | WTERMSIG(status)    | シグナルで終了したときに、そのシグナル番号を返す。 |
  |---------------------+----------------------------------------------------|

*** _exit(2)
- 
  statusを終了ステータスとしてプロセスを終了する。
  絶対に失敗しないので、呼び出したら戻らない。
  exit(3)と異なりlibc関連の後始末を行わない。

- def
  #include <unistd.h>
  void _exit(int status);

*** pipe(2)
- 
  両端とも自プロセスにつながったストリームを作成し、その両端のディスクリプタを返す。
  

- def
  #include <unistd.h>
  int pipe(int fds[2]);

*** getpid(2), getppid(2)
- 
  getpid()は自分のプロセスIDを返す。
  getppid()は親プロセスのppidを返す。

- def
  #include <sys/types.h>
  #include <unistd.h>
  pid_t getpid(void);
  pid_t getppid(void);

*** setsid(2)
- 
  新しいセッションを作成し、自分がセッションリーダーになる。
  同時にそのセッションで最初のプロセスグループを作成し、そのグループリーダーとなる。
  戻り値は作成したセッションID。失敗した場合は-1を返しerrnoをセットする。
  失敗する多くの場合は、自分がプロセスグループリーダーの場合なので、
  あらかじめ1回多くforkしておいてグループリーダーではなくなっている必要がある。
  制御端末を持たないため、デーモンとなる。

- def
  #include <unistd.h>
  pid_t setsid(void);

*** signal(2)
- 
  signalを捕捉するAPI。
  シグナルを送るAPIでなくtrapするAPIなので注意。
  
  シグナル番号sigのシグナルを受けたときの挙動を、
  第2引数funcの関数を呼ぶように変更する。
  このfuncに渡す関数を、シグナルを処理する関数という意味でシグナルハンドラ(signal handler)と呼ぶ。

  問題が色々とあるため、sigaction()を用いるのがよい。

- def
  #include <signal.h>
  void (*signal (int sig, void (*func)(int)))(int)

  (わかりにくいので少し書き直すと↓
   typedef void (*sighandler_t)(int);
   sighandler_t signal(int sig, sighandler_t func);
  )

- 第2引数funcで用いられる特別な値
  |---------+--------------------------------------------------|
  | 定数    | 意味                                             |
  |---------+--------------------------------------------------|
  | SIG_DFL | OSのデフォルトの動作に戻す                       |
  | SIG_IGN | カーネルレベルでシグナルを無視するように指示する |
  |---------+--------------------------------------------------|

*** sigaction(2)
- 
  sigaction()は第1引数のシグナルsigのハンドラを登録する。
  第2引数actにシグナルハンドラを指定する。具体的には関数ポインタかSIG_IGN, SIG_DFL。
  第3引数のoldactには、sigaction()呼び出し時のハンドラが返る。不要ならNULLを指定する。
  struct sigcationのsa_sigcationもシグナルハンドラを指定するメンバで、
  受信したときにシグナル番号以外の情報を得ることが出来る。
  
- def
  #include <signal.h>
  
  int sigaction(int sig, const struct sigaction *act,
                struct sigaction *oldact);
  
  struct sigaction {
      /* sa_handler, sa_sigactionは片方のみ使う */
      void (*sa_handler)(int);
      void (*sa_sigaction)(int, siginfo_t*, void*);
      sigset_t sa_mask;
      int sa_flags;
  };

- signalの問題点に対する対処
  - ハンドラの再設定
    sigaction()はOSに関わらずシグナルハンドラの設定を保持し続けることを保証する。
  - システムコールの再起動
    sigaction()はデフォルトでシステムコールを再起動しない。
    sa_flagsメンバにフラグSA_RESTARTを追加すると再起動する設定になる。
    一般には再起動されるほうが便利なので、SA_RESTARTを常に追加しておくのが無難。
  - シグナルのブロック
    sa_maskでブロックするシグナルを指定できる。
    シグナルハンドラの起動中は処理中のシグナルを自動的にブロックしてくれるので、
    ほとんどの場合はsa_maskは空にしておけば十分。空にするにはsigemptyset()を使う。

- sigset_t操作API
  - int sigemptyset(sigset_t *set);
    setを空に初期化する
  - int sigfillset(sigset_t *set);
    setをすべてのシグナルを含む状態にする
  - int sigaddset(sigset_t *set, int sig);
    シグナルsigをsetに追加する
  - int sigdelset(sigset_t *set, int sig);
    シグナルsigをsetから削除する
  - int sigismember(const sigset_t *set, int sig);
    シグナルsigがsetに含まれるとき真をかえす

- シグナルのブロック
  ブロックしていたシグナルを配送してもらうためのAPI。
  sigprocmaskは自プロセスのシグナルマスクをセットする。
  セット方法はフラグhowで決まる。
  sigpendingは保留されているシグナルをsetに書き込む。
  成功したら0、失敗したら-1を返しerrnoをセットする。
  sigsuspendはシグナルマスクmaskをセットすると同時にプロセスをシグナル待ちにする。
  ブロックしていたシグナルを解除して、保留されていたシグナルを処理するときに使う。
  sigsuspendは常に-1をかえす。

  - def
    #include <signal.h>
    
    int sigprocmask(int how, sigset_t *set, sigset_t *oldset);
    int sigpending(sigset_t *set);
    int sigsuspend(const sigset_t *mask);

  - sigprocmaskのhow値
    |-------------+---------------------------------------------------|
    | 値          | 効果                                              |
    |-------------+---------------------------------------------------|
    | SIG_BLOCK   | setに含まれるシグナルをシングルマスクに追加する   |
    | SIG_UNBLOCK | setに含まれるシグナルをシグナルマスクから削除する |
    | SIG_SETMASK | シグナルマスクをsetに置き換える                   |
    |-------------+---------------------------------------------------|

*** kill(2)
- 
  シグナルを送信するシステムコール。
  プロセスIDがpidのプロセスにシグナルsigを送信する。
  成功したら0を返す。失敗したら-1を返し、errnoをセットする。
  pidが負数のときは、IDが-pidのプロセスグループ全体にシグナルを送る。
  プロセスグループにシグナルを送るには、killpg()という専用のシステムコールもある。

- def
  #include <sys/types.h>
  #include <signal.h>
  
  int kill(pid_t pid, int sig);

*** chdir(2)
- 
  自プロセスのカレントディレクトリをpathに変更する。
  成功したら0、失敗したら-1を返しerrnoをセットする。

- def
  #include <unistd.h>
  int chdir(const char *path);

*** getuid(2), getgid(2)
- 
  現在のクレデンシャルを得る。
  getuidは実ユーザIDを、geteuidは実行ユーザIDを、
  getgidは実グループIDを、getegidは実行グループIDを、
  それぞれ返す。
  これらのシステムコールは失敗しない。

- def
  #include <unistd.h>
  #include <sys/types.h>
  
  uid_t getuid(void);
  uid_t geteuid(void);
  gid_t getgid(void);
  gid_t getegid(void);

*** getgroups(2)
- 
  自プロセスの捕捉グループIDをbufに書き込む。
  捕捉グループIDがbufsize個より多い場合は、エラーを返す。
  成功した場合捕捉グループIDの数を、失敗した場合は-1を返してerrnoをセットする。

- def
  #include <unistd.h>
  #include <sys/types.h>
  
  int getgroups(int bufsie, gid_t *buf);

*** setuid(2), setgid(2)
- 
  setuid()は、実ユーザIDと実行ユーザIDをidに変更する。
  setgid()は、実グループIDと実行グループIDをidに変更する。
- def
  #include <unistd.h>
  #include <sys/types.h>
  
  int setuid(uid_t id);
  int setgid(gid_t id);

*** initgroups(2)
- 
  /etc/groupなどのデータベースを見て、
  ユーザuserの補足グループを自プロセスに設定する。
  また、第2引数のgroupも追加する。
  groupは通常、ユーザのグループ(primary group)を補足グループにも追加するために使う。
  成功したら0を返す。失敗したら-1を返しerrnoを設定する。
  スーパーユーザでないと成功しない。

- def
  #define _BSD_SOURCE
  #include <grp.h>
  #include <sys/types.h>
  
  int initgroups(const char *user, gid_t group);

*** getrusage(2)
- 
  プロセスのリソース使用量を第2引数usageに書き込む。
  第1引数whoがRUSAGE_SELFならば自プロセスのリソース使用量を書き込む。
  第1引数whoがRUSAGE_CHILDRENならば子プロセスのリソース使用量を書き込む。
  この場合の子プロセスは「自プロセスからfork()した子プロセス全てのうち、waitしたもの」を意味する。
  呼び出しが成功したら0を返す。失敗したら-1を返してerrnoをセットする。

- def
  #include <unistd.h>
  #include <sys/resource.h>
  #include <sys/time.h>
  
  int getrusage(int who, struct rusage *usage);

- struct rusage
  「man getrusage」には沢山のメンバがあるが、
  Linuxではそのうちの一部しか正しい値がセットされない。
  
  |----------------+-----------+--------------------------|
  | 型             | メンバ名  | 意味                     |
  |----------------+-----------+--------------------------|
  | struct timeval | ru_utime  | 使われたユーザ時間       |
  | struct timeal  | ru_stime  | 使われたシステム時間     |
  | long           | ru_majflt | メジャーフォールトの回数 |
  | long           | ru_minflt | マイナーフォールトの回数 |
  | long           | ru_nswap  | スワップサイズ           |
  |----------------+-----------+--------------------------|

*** time(2)
- 
  UNIXエポックから現在までの経過秒数を返す。
  tptrがNULLでない場合は*tptrにも同じ値を書き込む。
  秒までの単位しか扱えない。

- def
  #include <time.h>
  time_t time(time_t *tptr);

*** gettimeofday(2)
- 
  UNIXエポックから現在までの経過時間をtvに書き込む。
  tzは既に使われていないので常にNULLを指定する。
  実行が成功したら0を返し、失敗したら-1を返しerrnoをセットする。

- def
  #include <sys/time.h>
  
  int gettimeofday(struct timeval *tv, struct timezone *tz);
  
  struct timeval {
      long tv_sec;   /* 秒 */
      long tv_usec;  /* ミリ秒 */
  };

** Commands
- 
  [[file:./Linux_Command.org][Linux_Command.org]]

** Boot Process
*** Switch
*** BIOS/UEFI
**** BIOS
**** UEFI
*** Bootloader
**** GRUB
**** LILO
*** Linux Kernel
*** Init daemon
**** SysVinit
- 
  First, kernel make init daemon start.
  then init gets services to start by following description of /etc/inittab.
  
  1. init read /etc/inittab
  2. init execute /etc/rc.sysinit
  3. init execute /etc/rc
  4. /etc/rc execute Start-up scripts on /etc/rc(runlevel).d

- /etc/rc*.d
  files on it are symbolic links of /etc/init.d

- log
  - /var/log/messages
    information of the whole system.
  - /var/log/boot.log
    information about whether each prosess status when booting up is ok or not.
  - /var/log/dmesg
    messages when system booting

- 
  [[http://www.seinan-gu.ac.jp/~shito/old_pages/hacking/shell/sh/boot_shutdown.html][initデーモンを理解する--Debian編（bootとshutdown時に自動的に実行されるプログラムの 仕組み）]]

**** Upstart
**** Systemd
***** Unit
- Feature
  1. Configuration file, not script.
  2. Being able to define relation among units.
  3. Some kind of files existing

- Kind
  |-----------+---------------------------------------------|
  | extention | content                                     |
  |-----------+---------------------------------------------|
  | .service  | settings about process start/stop           |
  | .mount    | settings about mount/unmount of file system |
  | .socket   | about monitoring socket connection          |
  | .device   | device informations system recognized       |
  | .path     | monitoring path                             |
  | .target   | gatherd several units                       |
  |-----------+---------------------------------------------|

- Path
  - /usr/lib/systemd/system
    inital settings. not operating it.
  - /etc/systemd/system
    individual settings by users.
    it is superior to read than the file above(/usr~),
    so you can copy the settigns of the file and edit when you want to change default settings.

***** Link
- http://equj65.net/tech/systemd-boot/
- http://enakai00.hatenablog.com/entry/20130914/1379146157
- http://www.slideshare.net/enakai/linux-27872553
- http://www.slideshare.net/moriwaka/systemd

**** launchd
** Files
*** /dev/pts/number
*** /etc/inittab
- 
  being read by init process for the first time system starting.

- format
  id:runlevels:action:process

  - action
    |-------------+-----------------------------------------------------|
    | action      | meaning                                             |
    |-------------+-----------------------------------------------------|
    | respawn     | starting process, and restarting when it stops      |
    | wait        | starting process, and waiting stop                  |
    | once        | executing once when transferred to target runlevel. |
    | initdefault | default run level                                   |
    | sysinit     | process when booting systems                        |
    | powerfail   | process when                                        |
    | powerokwait |                                                     |
    | ctrlaltdel  | the case when [Ctrl] + [Alt] + [Delete] are pressed |

*** /etc/rc*.d
- 
  files on it are symbolic links of /etc/init.d

*** /etc/rc.sysinit
*** /etc/passwd
- Format
  ユーザ名:暗号化パスワード:UID:GID:ユーザのフルネーム:ユーザのホームディレクトリ:ログインシェル

*** /etc/group
- Format
  グループ名:パスワード:GID:ユーザアカウントのリスト(カンマ区切り)

*** /etc/nsswitch.conf
- 
  ネームサービススイッチ(NSS)の設定ファイル。
  いろいろなカテゴリの名前サービス情報を、どの情報源からどの順序で取得するかを判断するのに使用される。
  
*** /etc/logrotate.d
- 
  
- commands
  - daily
  - weekly
  - monthly
    頻度の指定

  - missingok
    ログファイルが存在しなくてもエラーを出さずに処理を続行
  - nomissingok
    ログファイルが存在しない場合にエラーを出す
    
  - ifempty
    ログファイルが空でもローテーションする
  - notifempty
    ログファイルが空ならローテーションしない

  - create
    ローテーション後に空のログファイルを新規作成。
  - nocreate
    新たな空のログファイルを作成しない。
    
  - compress
    ローテーションしたログをgzipで圧縮
  - delaycompress
  - nocompress
    ローテーションしたログを圧縮しない

  - olddir [dirname]
    指定したディレクトリにログを格納
  - noolddir
    ローテーション対象のログと同じディレクトリにログを格納

  - sharedscripts
    複数指定したログファイルに対し、postrotateまたはprerotateで記述したコマンドを実行
  - postrotate～endscript
    間に記述されたコマンドをログローテーション後に実行
  - prerotate～endscript
    間に記述されたコマンドをログローテーション前に実行

*** /etc/fstab
- 
  起動時にマウントされるデバイスの一覧。

*** /etc/mtab
- 
  現在マウントされているデバイス一覧。
  手動でマウントしたものなど、mountコマンドに

*** /etc/sysconfig/iptables
- 
  iptables, setting of firewalls.

*** /proc/cpuinfo
- cpuの情報が含まれている
  コア数など調べることができる。

- Processer数（各種計）
  cat /proc/cpuinfo | grep processor

- 物理CPU数
  cat /proc/cpuinfo | grep "physical id"
  同じ番号は同じ物理CPU

- コア数
  cat /proc/cpuinfo | grep "cpu cores"
  また、"core id"でcoreのidを見ることができる。

*** /proc/meminfo
- メモリーの情報が含まれている
  メモリサイズなど調べられる。

*** /var/spool/mail
- 
  mailbox. mails that have sent is saved here temporary.
  later read them by mail command or POP3 for mailer, etc.

- how to clear
  cat /dev/null > /var/spool/mail/root

*** /var/log/messages
- 
  standard kernel / OS log

*** /var/log/secure
- 
  connected ssh logs

*** /var/log/cron
- 
  logged cron executed

** Environment Variables
- 
  see list with "printenv"

*** LANG
- 
  you can change messages on the shell by changing LANG variable
  ex) export LANG=en_US.UTF-8
  also you can use "export LANG=C"
  if you like to use Japanese, set ja_JP.UTF-8
*** HOSTNAME

*** SHELL

*** PATH

*** HOME

** Shells
*** bash
*** csh
*** tcsh
*** zsh
- [[file:./Zsh.org][Zsh.org]]

** Distributions
*** Debian

*** Ubuntu

*** CentOS

*** RHEL

*** CoreOS
** Package Management
*** apt
**** aptitude
*** dnf
- 
  Dandified Yum
  rpm-based package system.
  The next generation version of yum.

*** yum
- 
  Yellowdog Updater Modified.
  interactive, rpm based, package manager.
  yumは内部でrpmを呼び出していて、rpmよりも高度。
  
**** install
- 
  install the latest version of a package or group packages while ensuring that all dependencies are satisfied.

- -y
  answer "yes" to questions in the install message.

**** update
- 
  If run without any packeages, update will update every currently installed package.
  
**** upgrade

**** remove

**** list
- 
  find out which package provides some feature or file.

**** info
- 
  show details.

**** clean

**** search
- 
  This is used to find packages when you know something about package
  but aren't sure of it's name.

*** rpm
** Memo
*** アクセス権の補助フラグ
**** suid
- 
  set user id。
  コマンドを実行するユーザに関係なく特定のユーザで実行したいときに、
  ファイルパーミッションのset-uidビット(set-user-ID bit)を立てておくと、
  起動したユーザに関わらず、ファイルのオーナー権限で起動される。
  パーミッションのxがsと表示される。
  setuid()システムコールとは何の関係もない。
-
  起動ユーザIDを実ユーザID(real user ID)、
  オーナーIDを実行ユーザID(effective user ID)という。

**** sgid
- 
  set group id。
  suidとほとんど同じなのでそちらを参照。

- 
  起動ユーザグループIDを実グループID(real group ID)、
  プログラム所有グループIDを実行グループID(effective group ID)という。

**** sticky
- 
  実行が終了した後もメモリ内にプログラムを残しておくようにカーネルへ要求する。
  再実行する際に高速に処理をすることを目的とするが、メモリの大容量化に伴い、使われなくなっている。

*** heredoc
- 
  ヒアドキュメント。
  << の後にデリミタとなる識別子を続け、最初に指定した識別子だけの行がくるまで入力が続く。
  
  - 行頭を<<-ではじめることで、行頭のタブが無視され、インデントを崩さずヒアドキュメントを書ける。
  - デフォルトでは、変数展開やバッククオートのコマンド展開が行われる。($PWD等)
  - デリミタを引用符で囲むことで(<< "EOF")、コマンド展開等を無効にできる。

- ex:)
    cat > ~/.bashrc << "EOF"
    set +h
    unmask 022
    EOF

*** Ctrl-s
- 
  スクロール停止キー。画面がフリーズしたように見える。
  ログを見ていて、一時的にとめておくために使ったりする。
  解除はCtrl-q

*** glob
- 
  シェルが*?{}[]~などを解釈し、ファイル名として展開することをグロブ（ファイルグロブ）という。
  正規表現とは別物。
  働かせたくない場合は""等で囲む。
  ちなみにWindowsではLinuxと異なりプログラム側で展開する。

*** tty, pts
- tty
  端末を表すttyは、TeleTYpewriterの略。
  制御端末のこと。実端末。

- pts
  sshなどの仮想端末。

- ptmx

*** standard input/output
- 
  |----------------+---------------+--------+----------------|
  | FileDiscriptor | Macro         | stdio  | Meaning        |
  |----------------+---------------+--------+----------------|
  |              0 | STDIN_FILENO  | stdin  | 標準入力       |
  |              1 | STDOUT_FILENO | stdout | 標準出力       |
  |              2 | STDERR_FILENO | stderr | 標準エラー出力 |
  |----------------+---------------+--------+----------------|

*** sys/types.h システム定義型
OSやCPUの差異を隠蔽するために別名で基本型を再定義している。
- size_t
  符号なし整数型
- ssize_ti
  符号付き整数型

*** '\0'の有無
- 
  read(2)は終端に'\0'を想定していない。
  対して、printf()は末尾に'\0'を前提としているので、
  そのまま渡したり、合わせて使うのは間違い。
*** ミドルウェアのユーザ
- 
  Apacheなどのミドルウェアに対し、専用のユーザを作成することが多いが、
  セキュリティ対策としてログインシェルを無効化しておくことが多い。
  ログインシェルを無効化するには、そのユーザのログインシェルとして無効なファイルを指定する。
  そうすると、ログインを試みた場合に自動でログアウトされる。
  /bin/falseなどに設定しておく。

*** signal
- 
  実行中のプロセスに対し、さまざまなイベントを通知するために送出されるもの。
  SIGTERMやSIGKILLの他にも数十種類存在する。
  "kill -l"で参照可能。
  killコマンドでシグナルの送信が可能。
  また、シグナルを受信して処理するにはtrapコマンドが使える。

- よく使われるシグナル
  |------------------+------+------------+--------------------------------------------------------------------------------------------|
  | デフォルトの名前 | 補足 | 挙動       | 生成原因と用途                                                                             |
  |------------------+------+------------+--------------------------------------------------------------------------------------------|
  | SIGINT           | ○   | 終了       | 割り込み。Ctr+Cで生成され、中止したいときに使う。                                          |
  | SIGHUP           | ○   | 終了       | ユーザがログアウトしたときなどに生成、デーモンでは設定ファイルの読み直しに使う場合が多い。 |
  | SIGPIPE          | ○   | 終了       | 切れたパイプに書き込むと生成される。                                                       |
  | SIGTERM          | ○   | 終了       | プロセスを終了させるときに使う。killのデフォルト値。                                       |
  | SIGKILL          | ×   | 終了       | 確実にプロセスを終了させるために使う                                                       |
  | SIGCHLD          | ○   | 無視       | 子プロセスが停止または終了したときに生成される                                             |
  | SIGSEGV          | ○   | コアダンプ | アクセスが禁止されているメモリ領域にアクセスした。                                         |
  | SIGBUS           | ○   | コアダンプ | アラインメント違反。ポインタ操作を間違えたときに生成される。                               |
  | SIGFPE           | ○   | コアダンプ | 算術演算エラー。ゼロ除算や不動小数点数オーバーフローなど。                                 |
  |------------------+------+------------+--------------------------------------------------------------------------------------------|

*** ファイルの種類を判定するマクロ
- 
  |----------+----------------------------------|
  | マクロ名 | 効果                             |
  |----------+----------------------------------|
  | S_ISREG  | 普通のファイルなら非ゼロ         |
  | S_ISDIR  | ディレクトリなら非ゼロ           |
  | S_ISLNK  | シンボリックリンクなら非ゼロ     |
  | S_ISCHR  | キャラクタデバイスなら非ゼロ     |
  | S_ISBLK  | ブロックデバイスなら非ゼロ       |
  | S_ISFIFO | 名前付きパイプ（FIFO）なら非ゼロ |
  | S_ISSOCK | UNIXソケットなら非ゼロ           |
  |----------+----------------------------------|

*** パーミッションを表す定数
- 
  |-------------------+-------+--------------------------|
  | 定数              |    値 | 意味                     |
  |-------------------+-------+--------------------------|
  | S_IRUSR, S_IREAD  | 00400 | 所有ユーザから読込可能   |
  | S_IWUSR, S_IWRITE | 00200 | 所有ユーザから書込可能   |
  | S_IXUSR, S_IEXEC  | 00100 | 所有ユーザから実行可能   |
  | S_IRGRP           | 00040 | 所有グループから読込可能 |
  | S_IWGRP           | 00020 | 所有グループから書込可能 |
  | S_IXGRP           | 00010 | 所有グループから実行可能 |
  | S_IROTH           | 00010 | 所有グループから実行可能 |
  | S_IWOTH           | 00010 | 所有グループから実行可能 |
  | S_IXOTH           | 00010 | 所有グループから実行可能 |
  |-------------------+-------+--------------------------|

*** リダイレクト
- 
  標準入力が0, 標準出力は1, 標準エラー出力は2。

  標準出力サンプル。以下2つは同じ意味。
    echo Hello 1> hoge.txt
    echo Hello  > hoge.txt

  標準入力サンプル。以下2つも同じ意味。
    read fuga 0< hoge.txt
    read fuga  < hoge.txt

  標準エラー出力を標準出力にマージ
    some_command > hoge.txt 2>&1

*** コマンドの終了ステータス
- $?
  "$?"で直前の終了ステータスを取得できる。

- PIPESTATUS[]
  パイプライン内の任意の位置の終了ステータスを拾いたい場合、
  PIPESTATUSという環境変数を利用する。
  配列で、添え字は0始まり。
    ex) echo ${PIPESTATUS[0]}

*** 終了ステータス
- 
  0は成功、1はエラーというのは、Linux(UNIX)の決まりごと。
  成功・失敗のどちらかを表現するだけでよければ、
  EXIT_SUCCESSとEXIT_FAILUREというマクロを使うとよい。
  細かくステータスを分けたい場合、直接数値を書くべき。

*** 色属性のエスケープシーケンス
- ESC[色属性m
  上記のように書くことで、色属性が変更される。
  ESCはエスケープ文字だが、「\e」か「\033」もしくはESC制御文字(16進で"1b")を入力する。
  属性をリセットしデフォルトにするには、「ESC[0m」もしくは「ESC[m」とする。

- カラーコード
  カラーコード"31"の1文字目"3"は文字色指定を表す。
  また、"4"は背景色指定を表す。
  2文字目がカラーコードとなる。
  
  |------+---------|
  | 数字 | 色      |
  |------+---------|
  |    0 | Black   |
  |    1 | Red     |
  |    2 | Green   |
  |    3 | Yellow  |
  |    4 | Blue    |
  |    5 | Magenta |
  |    6 | Cyan    |
  |    7 | White   |
  |------+---------|

- 付加属性
  
  |----------+----------------+--------|
  | 属性番号 | attributes     | 属性   |
  |----------+----------------+--------|
  |        1 | bold           | 太字   |
  |        2 | low intensity  | 弱強調 |
  |        4 | underline      | 下線   |
  |        5 | blink          | 点滅   |
  |        7 | reverse video  | 反転   |
  |        8 | invisible text | 非表示 |
  |----------+----------------+--------|

- 例
  echo -e "\e[33;41;1mhoge\e[m"

- リンク
  [[http://www.m-bsys.com/linux/echo-color-1][シェル - echo で文字に色をつける その1]]
 
*** プロセス置換
- 
  コマンドの出力結果をファイルとして扱う機能。
  <(command)という形で使う。
    ex) diff text.txt <(sed -e 's/hoge/HOGE HOGE/' text.txt)

*** アドレス空間の確認
- 
  プロセスIDがｎのメモリ配置を見たければ、
  /proc/n/mapsを確認すればよい。
  
  pはprivateな領域、sはshared（共有）領域を表す。

*** zombie
- 
  fork()した後wait()しない場合に残っている状態。
  子が死んでも、親がwaitするときに備えてプロセス管理テーブル内の子エントリを開放せずに残しておくため、
  waitをしないといつまでも子エントリが残り続ける。
  ゾンビはリソースを開放しない上にシグナルは無視される。
  親プロセスがwaitせずに終了してしまった場合、initプロセスが自分の養子として引き受ける。
  psコマンドには"zombie"とか"defunct"と表示される。
  対策としては、1:forkしたらwait, 2:ダブルfork, 3:sigcation()を使う, などがある。

*** session
- 
  ユーザのログインからログアウトまでの流れを管理するための概念。
  ログインシェルを基点に、ユーザが同じ端末から起動したプロセスを1つにまとめる働きがある。
  結果プロセスグループをまとめるような形になる。
  最初にセッションを作ったプロセスがセッションリーダーで、
  psコマンド等で確認するとPID(プロセスID)とSID(セッションID)が等しい。
  リーダーは新しいセッションやプロセスを作れない。
  セッションと関連付けられた端末を、プロセスの制御端末(controlling terminal)という。
*** ログインセッション
- 
  特定の端末上でセッションを開始したプロセスの子孫のプロセスが全て含まれる。

*** process group
- 
  パイプでつなげたプロセス群全てに処理の中断を行ってもらいたい、など、
  ある程度まとまった単位にシグナルを送れるように遅れるようにしたもの。
  最初にプロセスグループを作ったプロセスがプロセスグループリーダーで、
  psコマンド等で確認するとPID(プロセスID)とPGID(プロセスグループID)が等しい。

*** daemon
- 
  制御端末を持たないプロセスをdeamon processという。
  "ps ax"などで確認すると、ttyが"?"となっている。
  
*** 他のプロセスのカレントディレクトリ
- 
  自プロセス以外のカレントディレクトリは変更できない。
  知るだけなら/proc/プロセスID/cwdで確認可能。

*** environment variable
- 重要な環境変数
  |---------+-----------------------------------------------------|
  | 名前    | 意味                                                |
  |---------+-----------------------------------------------------|
  | PATH    | コマンドの存在するディレクトリ                      |
  | TERM    | 使っている端末の種類                                |
  | LANG    | ユーザのデフォルトロケール。                        |
  | LOGNAME | ユーザのログイン名                                  |
  | TEMP    | 一時ファイルを置くディレクトリ。/tmpなど。          |
  | PAGER   | manなどで起動するテキスト閲覧プログラム。lessなど。 |
  | EDITOR  | デフォルトエディタ。viやemacsなど                   |
  | MANPATH | manのソースをおいてあるディレクトリ                 |
  | DISPLAY | X Window Systemのデフォルトディスプレイ             |
  |---------+-----------------------------------------------------|

- environ
  グローバル関数environを介して環境変数にアクセスできる。
  型はchar**で、どのヘッダファイルでも宣言されていないので、
  自分で直接extern宣言をする必要がある。
  environの指す先は移動することがあるので、変数に保存しあとで使う等してはいけない。
  ex) extern char **environ;
*** ユーザ時間、システム時間
- システム時間
  そのプロセスのためにカーネルが働いた時間のこと。
- ユーザ時間
  システム時間以外の、プロセスが完全に自分で消費した時間のこと。

*** メジャーフォールト、マイナーフォールト
- メジャーフォールト major fal
  
- マイナーフォールト
*** UNIX epoch
- 
  Linuxカーネルは時刻を1970年1月1日からの経過秒数で保持している。
  この日時を俗に"UNIXエポック"と呼んでいる。
  1970年なのはUNIXの最初のバージョンがその頃に出来たため。
  Linuxカーネルでは常に協定世界時(UTC : Coordinated Universal Time)で計算している。

*** ログイン
- 
  ログインの流れ
  1. initが端末の数だけgettyコマンドを起動(/ect/linittabに設定値)
  2. 端末からのユーザ名入力を待ち、loginコマンドを起動
     gettyは端末をopen()し、read()して、ユーザ名がタイプされるのを待つ。
     端末の細かい設定などが必要なので、gettyという独立プログラムが必要。
     ユーザ名が入力されたら、dup()を使って0, 1, 2番につなぎ、loginをexecする。
  3. loginコマンドがユーザ認証
     ユーザデータベースのある場所等の差異は、/etc/nsswitch.confの設定にある。
     パスワードはPAMがあればそこで吸収、導入されていなければloginコマンドで意識する必要あり。
     伝統的には/etc/login.defsで設定していた。
  4. シェルを起動
     execするときにコマンドの頭に「-」をつけて起動数rと、ログインシェルとなり、動作が少し変わる。
     例）execl("/bin/sh", "-sh", ....);

*** PAM
- 
  Pluggable Authentication Module。
  実態は共有ライブラリだが、柔軟に対応できるようダイナミックロードを使ってライブラリを分割している。
  ライブラリは/lib/security。

*** sshの秘密鍵接続
- 
  ssh-keygenで、秘密鍵と公開鍵を作成する。
  "~/.ssh/authorized_key"に公開鍵を登録してあげることで、パスワードを入れなくてもssh接続できるようになる。
  パーミッションは600にしておくこと。

*** sudo管理者権限
- 
  sudoコマンドは、設定をしていない場合は一般ユーザは使用できない。
  設定ファイルは/etc/sudoersだが、そのままviで編集してはいけない。
  設定ミスが問題になりうるので、ファイルのロックや構文の確認をしてくれるvisudoコマンドを使う。
  [[http://linux.kororo.jp/cont/intro/sudo.php][sudoによる管理者権限の付与]]

*** serviceと/etc/init.d/xxxの違い
- /etc/init.d/xxx start
  コマンドを実行したときの環境変数がそのまま引き継がれる。
- service xxx start
  環境変数はPATHとTERMのみ引き継がれる。
*** プロセスディスクリプタ
- 
  プロセスの実行を停止する際、カーネルはその時点でのプロセスの内容をディスクリプタの中に退避する。
  レジスタはPCやSP、汎用レジスタ、浮動小数点レジスタ、プロセッサ制御レジスタ、メモリ管理レジスタなど。
  実行再開時に、退避していたプロセスディスクリプタのメンバを使用し、CPUレジスタを復旧する。

*** スピンロック
- 
  ロックの一種で、スレッドがロックを獲得できるまで単純にループ（スピン）して定期的にロックをチェックしながら待つ方式。
  セマフォを使用する場合複数の処理が必要となるため、短期間のブロックではスピンロックの使用が効果的である。
  そのため、カーネル内でよく使われる。

*** IPC
- 
  IPCはInterprocess Communication。
  System V IPCとして、セマフォ(semaphore)、メッセージキュー(message que)、共有メモリ(shared memory)がある。
  shmget(), semget(), msgget()といったシステムコールを呼び出すことで、カーネルはIPC資源を獲得する。

*** プロセスグループ
- 
  ex) ls | sort | more
  上記のようなコマンドラインを実行する場合、bashのようなプロセスグループを扱えるシェルでは、
  3つのプロセス用の新しいグループを生成する。
  シェルは、その3つのプロセスをあたかも1つであるかのように取り扱う。各プロセスディスクリプタにはプロセスグループIDメンバがある。

*** ディストリビューションの確認
- 
  /etc配下にディストリビューションやバージョンが書いてあるファイルがあるので、
  それを確認する。
  ex)
  - cat /etc/redhat-release (Redhat)
  - cat /etc/debian_version (Debian)
  - cat /etc/SuSe-release (SuSE)
  - cat /etc/vine-release (Vine)
  
  もしくは、issueに入っているとのこと。
  - cat /etc/issue

  [[http://d.hatena.ne.jp/PRiMENON/20080119/1200750903][インストールしたLinuxディストリビューション名とバージョンを確認するには]]

*** スーパーブロック
- 
  論理パーティションを管理するためのメタデータ。
  細かい点は不明。リンク参照。
  
- Link
  [[https://ja.wikipedia.org/wiki/%E3%82%B9%E3%83%BC%E3%83%91%E3%83%BC%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF_(%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0)][スーパーブロック（ファイルシステム） - Wikipedia]]
  [[http://open-groove.net/linux/linux-filesystem-superblock/][Linuxファイルシステムにおけるスーパーブロックとは - OpenGroove]]

*** IFSの変更
- 
  シェルの区切り文字を指定する、"IFS(Internal Field Separator)"という変数がある。
  スペースと改行がデフォルトで区切り文字となっているが、スペース区切りの行を一つのまとまりとして認識したい場合、
  IFS=$"\n" とすることで改行のみを区切り文字として変更可能。
  （もとのIFSはバックアップを取っておいて、変更後もとに戻すとよい）

- 
  [[http://linux.just4fun.biz/%E9%80%86%E5%BC%95%E3%81%8D%E3%82%B7%E3%82%A7%E3%83%AB%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88/%E3%82%B9%E3%83%9A%E3%83%BC%E3%82%B9%E3%81%8C%E5%90%AB%E3%81%BE%E3%82%8C%E3%82%8B%E6%96%87%E5%AD%97%E5%88%97%E3%82%921%E8%A1%8C%E3%81%A8%E3%81%97%E3%81%A6%E6%89%B1%E3%81%86%E6%96%B9%E6%B3%95.html][スペースが含まれる文字列を1行として扱う方法 - 逆引きシェルスクリプト]]

*** how to change forgotten root password
**** centos
- 
  1. Boot CenTOS and press esc key when seeing the message "Press any key to enter the menu"
  2. Select your operating system and press 'a' to modify kernel argument.
  3. Pet number "1" or character "S" in kernel configuration.
  4. Starting with single mode, command 'pwd' and change password.

- Link
  [[http://lintut.com/reset-forgotten-root-password-in-centos/][Easy way to reset forgotten root password in CentOS 6.5 - LinTut]]

*** change kbdmap
- setxkbmap dvorak
  change xkeyboardmap to dvorak.

- loadkeys
  loadkeys dvorak.map
  loadkeys /usr/share/keymaps/i386/dvorak/dvorak.map.gz

- Link
  [[http://www.kaufmann.no/roland/dvorak/linux.html][Installing the Programmer Dvorak Keyboard Layout on Linux]]

*** check OS x86 or x86_x64
- 
  type "uname -a"
*** extend lvm volumes
- create partition
  fdisk /dev/sda
  (type some commands like p(print), n(add)->p, m(help), t(change system id), w(write table to disk and exit) etc)
  
- reboot
  reboot
  
- create lvm physical volume
  pvcreate /dev/sda3

- check volumegroup
  vgs

- set phsycal volume to volume group
  vgextend VolGroup00 /dev/sda3

- extend logical volume
  lvextend -l +100%Free /dev/VolGroup00/LogVol00

- resize file system
  resize2fs /dev/VolGroup00/LogVol00

- check the size
  df -h

- [[https://users.miraclelinux.com/technet/document/linux/training/2_2_3.html][Linux技術トレーニング 基本管理コースⅡ - MIRACLE]]
- [[http://se-suganuma.blogspot.jp/2009/04/centoslvmvmwarehdd.html][【CentOS】LVMでディスク容量を拡張（VMwareのHDD容量を増やす） - SE奮闘記]]
  
*** iptables
- 
  the command to configure the tables,chains and rules provided by Netfilter,
  which is Linux kernel firewall for packet processing.
  Packet Filtering, Network Address Translation modules for IPv4.

  ip6tables for IPv6, arptables to ARP, ebtables to Ethernet frames.
  
- Tables
  choose tagret to filter
  - filter
    control packet accessing, droping.
    - chain : INPUT, OUTPUT, FORWARD
  - nat
    overwrite packet source or destination etc.
    - chain : POSTROUTING, PREROUTING, OUTPUT
  - mangle
    overwiret TOS (Type Of Services) field.
    - chain : POSTROUTING, PREROUTING, INPUT, OUTPUT, FORWARD
  - raw
    Mark special packet not to tracking.
    - chain : PREROUTING, OUTPUT

  - settings
    *filter(nat, mangle, raw)
      #write down settings
    COMMIT

- Chains
  - INPUT
    Packets is going to be locally delivered.
    It does not have anything to do with processes having an opend socket;
  - OUTPUT
    output packet
  - FORWARD
    forwarding packet
  - PREROUTING
    Packets will enter this chain before a routing decision is made
  - POSTROUTING
    Rounting decision has been made. Packets enter this chain just before handing them off to the hardware.

- Targets
  - ACCEPT
    allow packet passing.
  - DROP
    drop packets.
  - RETURN

  - MASQUERADE
    
  - REJECT
    reject packets and not reply.
  - REDIRECT, PREROUTING
    redirect other ports.
  - LOG
    write log.
    
- Rules
  - -p [!] <protocol>
    protocol.
    able to choose one of following : tcp, udp, icmp, all

  - -s [!} <address> [/<netmask>]
    source IP

  - -d [!] <address> [/<netmask>]
    destination IP

  - --sport <port>
    source port
  - --dport <port>
    destination port
  
  - -j <target>
    
  - -i <interface>
    input interface. eth0, eth1, etc.

  - -o <interface>
    output interface.
  
  - -t <table>
    target table

  - -m <module>
    set module.
  
*** SELinux
- 
  Security-Enhanced Linux.

- status
  - diabled
  - permissive
    write audit log only
  - enforcing

- command for checking status
  - getenforce
    return Disabled, Permissive or Enforcing
  - setlinuxenabled
    when disabled, return 1. others, return 0.
    check with "echo $?"
  - sestatus
    most detailed.

- command for change status
  - setenforce 0
    set permissive.
  - setenforce 1
    set enforcing

- setting file
  - /etc/selinux/config

  - /etc/sysconfig/selinx
    symbolic link of /etc/selinux/config.
    change above one.

- auditlog
  - /var/log/audit/audit.log
  - ausearch -m avc

**** TE - Type Enforcement

**** RBAC

**** MAC

**** Domain

*** Unset autolock 
- CentOS
  System->Preferences->Screensaver
  uncheck : Lock screen when screensaver is active

*** RHEPL/CentOS Development Tools
- 
  install some Development Tools.
  yum groupinstall 'Development Tools'
  [[http://www.cyberciti.biz/faq/centos-linux-install-gcc-c-c-compiler/#more-1210][RHEL/CentOS Linux Install Core Development Tools Automake, Gcc(C/C++), Perl, Python & debuggers - nixCraft]]

*** Check i-node inoformation
- 
  i-nodeがどれだけ使われているかは、"df -i"で調べられる。
  また、特定のファイルやディレクトリのiノード情報は、"stat"コマンドで確認できる。

*** Copy directory structure without files
- 
  find . type >dirs.txt
  xargs mkdir -p <dirs.txt
  [[http://stackoverflow.com/questions/4073969/copy-folder-structure-sans-files-from-one-location-to-another][Copy folder structuer (sans files) from one location to another - stackoverflow]]

- 
  find workarea_root -type d -exec echo doing/{} \; | xargs mkdir -p

*** Get ShellScript's Location Path
- 
  cd, and then pwd.
  only executing pwd, it shows a current position where command is executed.

  - ex
    echo $(cd $(dirname $0) && pwd)

- Link
  [[http://www.task-notes.com/entry/20150214/1423882800][シェルスクリプトで相対パスと絶対パスを取得する - TASK NOTES]]
*** About LVM
**** Disk
**** Physical Volume
**** Volume Group
**** Logical Volume
**** Mount Point
*** lost+found
- 
  running fsck, and it might find data fragments that are 
  [[http://unix.stackexchange.com/questions/18154/what-is-the-purpose-of-the-lostfound-folder-in-linux-and-unix][What is the purpose of the lost+found folder in Linux and Unix? - UNIX & LINUX]]

*** /etc/mtab, /proc/mounts
- /etc/mtab
  通常のファイルで、ファイルシステムがマウント・アンマウントされると常にmountプログラムによって更新される。
- /proc/mounts
  proc仮想ファイルシステムの一部。/proc/配下にある他のファイルと同様、mounts"ファイル"はどとディスクドライブにも存在しない。
  実際にはファイルでもなく、ファイル形式で見ることができるシステム状態。
- 
  [[http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ja-4/s1-storage-rhlspec.html][5.9. Red Hat Enterprise Linux 固有の情報 - Red Hat Enterprise Linux 4: システム管理入門ガイド 5章. ストレージを管理する]]

*** 監視はtail -fでなくless +Fでよい
- 
  less +Fを使うことにより、監視モードと通常モードをlessを起動したまま行き来できるので、
  tailよりも便利、とのこと。
  [[http://www.softantenna.com/wp/unix/stop-using-tail-f/][「tail -f」を使うのは情弱、情強は「less +F」を使う - ソフトアンテナブログ]]

*** CPU数、コア数、ハイパースレッディングの調査
- 
  cat /proc/cpuinfo | grep (processor | "physical id" | "cpu cores" | etc.. )
  [[http://tooljp.com/linux/faq/5B503D6E4FD173C549257A570051833A.html][【質問】CPU数、コア数、ハイパースレッディング (Hyper-Threading) を調査する方法 - Redhat Enterprise linux (EL) FAQ]]

*** メモリの確認
- 
  cat /proc/meminfo

*** spool
- Simultaneous Peripheral Operation On-Line
  もともとはIBM用語。
  転じて、FIFO(キュー)と呼ばれるバッファとして使われている。

*** MTA
- Mail Transfer Agent

**** sendmail
- 
  MTAの中でもUNIXで古くから使われてきたソフト。
  ほとんどのUNIX系OSにデフォルトでインストールされており、通常/etc/mailに設定ファイルが集められている。
- 
  http://rfs.jp/server/sendmail/sendmail.html
*** Linuxサーバ確認オペレーション
- Link
  - [[http://yuuki.hatenablog.com/entry/linux-server-operations][Linuxサーバにログインしたらいつもやっているオペレーション - ゆううきブログ]]
  - [[http://think-t.hatenablog.com/entry/20090218][サーバを調査するときにやること(Linux編) - think-t の晴耕雨読]]
  - [[http://techblog.netflix.com/2015/11/linux-performance-analysis-in-60s.html][Linux Performance Analysis in 60,000 Milliseconds - The Netflix Tech Blog]]

**** まず確認すること
***** w
- 他のユーザを確認
***** uptime
- サーバの前回起動してから現在までの稼働している時間の確認。
  ただしwでも同様の情報が出る。
***** ps
- ps auxf
- pstreeでも似たようなことが可能
***** ip
- ip a
***** df
- df Th
**** 負荷状況確認
***** top
- top -c, 更に1を押す
- mpstat -P ALLでも見れる
***** iostat
- iostat -dx 5
***** netstat / ss
- netstat -tnl

**** ログ調査
***** /var/log/messages or /var/log/syslog
- カーネルやOSの標準的なプロセスログ
***** /var/log/secure
- ssh接続の情報
***** /var/log/cron
- cronが実行されたか否か確認
***** /var/log/nginx, /var/log/httpd, /var/log/mysql
- middlewareログは、/var/log/{middleware}にある場合が多い。
***** /etc
- /etc/{middleware}辺りにログなどの設定ファイルが書いていないか確認する。
***** lsof
- lsof -p <pid>
  <pid>が開いたファイルディスクリプタ情報が見えるので、そこからログファイルなどを探す。
*** 他のユーザにメッセージを送る
- write:
  to a perticular user
  - usage 
    write [username]
    messages...
  
- wall:
  to all users logging in
  send a message to everybody's terminal.
  - usage
    wall 

- pts
  echo "message here" > /dev/pts/num
*** net-tools, iproute2
**** net-tools
***** arp
***** hostname
***** ifconfig
***** ipmaddr
***** iptunnel
***** mil-tool
***** meif
***** netstat
***** plipconfig
***** rarp
***** route
***** slattach
**** iproute2
***** ip
***** ss
**** Link
- [[http://www.linuxfoundation.org/collaborate/workgroups/networking/net-tools][net-tools THE LINUX FOUNDATION]]
*** extundelete (rmしてしまった場合の復元)
- 
  1. 書き込まれないように、readonlyなどにしてマウントし直す。
  2. 時間をとっておく。
  3. extundeleteをインストール、ビルド。ext3, ext4に対応しているらしい。
  4. パーティションと時間（エポック秒）を指定してextundeleteを実行、復元。
  5. 名前が戻せないものは、ディレクトリ直下にfiles.{inode番号}みたいな形で並ぶ。
  
- 
  [[http://d.hatena.ne.jp/y-kawaz/20110123/1295779916][Linuxでうっかりrm -rfしちゃったけど復活出来たよー＼(＾o＾)／  - y-kawazの日記]]
  [[https://tech.aucfan.com/rm-rf-retrieval/][rm -rfでやらかした時すかさず実行する復元コマンド(Linux編) - aucfan Engineer's blog]]
*** ANSI escape code
- 
  ターミナル上で文字を強調したりできる。
  CSI(Control Sequence Introducer)と呼ばれるEsc / [を先頭につけた形とし、
  その後に数字を続ける。
  [[http://shiroyasha.io/escape-sequences-a-quick-guide.html][Escape Sequences - A Quick Guide]]
  https://en.wikipedia.org/wiki/ANSI_escape_code
*** パイプの入力をシェルコマンドとして実行
- 
  sh、でパイプで受け取った文字列をシェルコマンドとして実行できる。
  ex) echo 'hoge foo var' | sed 's/^/mkdir /' | sh -x
  http://d.hatena.ne.jp/srkzhr/20081216/1229449984
