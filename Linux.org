* Linux

** Linux OS
*** 構成要素

- shell
  bash, ash, csh, tsch, zsh, pdksh, ...
- util-linux
  init, getty, login, reset, fdisk, ...
- procps
  ps, pstree, top, ...
- GNU coreutils
  ls, cat, mkdir, rmdir, cut, chmod, ...
- GNU grep, find, diff
- GNU libc
- libraries 
  ncurses, GDMB, zlib, ...
- development enviroment
  gcc, binutils, make, bison, flex, headerfiles, ...
- X Window System
- GNOME, KDE
(「ふつうのLinux」p.27)

*** アドレス空間の構造

- テキスト領域
  機械語のプログラム
- データ領域
  グローバル変数や関数内のスタティック変数のうち初期化済みのもの、
  文字列リテラルがおかれる。
- BSS領域
  グローバル変数や関数内のスタティック変数のうち初期化が必要ないものがおかれる。
- ヒープ領域
  malloc()が管理する領域
- スタック領域
  関数呼び出しに関連したデータを置くところ。
  関数の引数やローカル変数がおかれる。

** File
- memo
  以下は広義ではすべてファイル。

- regular file
- directory
- symbolic link
- device file
  - character device file
    プリンタやモデムなど
  - block device file
    ハードディスクなど
- named pipe
  プロセス間通信に使うファイル。FIFO。
- UNIX domain socket

** directory

*** / (FHS)
- 
  第一階層、ルートディレクトリ

**** /bin
- 
  シングルユーザモードで必要となる一般ユーザ向け基本コマンドの実行ファイル。
  /usr/binはシングルユーザ以外の一般ユーザ向けコマンド。
  
- 
  必須: 
  cat, chgrp, chmod, chown, cp, date, dd, df, dmesg, echo, false, hostname,
  kill, ln, login, ls, mkdir, mknod, more, mount, mv, ps, pwd, rm, rmdir,
  sed, sh, stty, su, sync, true, unmount, uname

- 
  オプション: 
  csh, ed, tar, cpio, gzip, gunzip, zcat, netstat, ping

**** /boot
- 
  ブートローダ関連のファイル群。カーネルやinitrd。通常別パーティション。
  カーネルは、vmlinuzに格納されている。
  unix -> vmunix（仮想メモリ機構追加） -> vmlinux -> vmlinuz（圧縮）のように変遷した。

**** /dev
- 
  基本デバイス。/dev/null, /dev/consoleなど。
  Linux2.4ではdevfsという仕組みが導入されたが、USBなどと相性が良くなかったため、
  Linux2.6以降はudevという仕組みが使われる。
  defvsはカーネルの一部だが、udevはカーネルの外。

**** /etc
- 
  システム全体の固有設定ファイル群。バイナリファイルを置かない。
  fstab, gateway, group, hosts, password, profile, servicesなど。

***** /etc/opt
- 
  /opt/のための設定ファイル群。
***** /etc/X11
- 
  X Window System用の設定ファイル群。
***** /etc/sgml
- 
  sgml設定ファイル群。
***** /etc/xml
- 
  xml設定ファイル群。
**** /home
- 
  ユーザのホームディレクトリ。オプション。

**** /lib
- 
  /bin や /sbin にある実行ファイルの基本となるライブラリ群。

**** /lost+found (FHSの規定にはなし)
- 
  fsckでディスクチェックした際に作られる、破損ファイルの断片を収めるディレクトリ。

**** /media
- 
  CD-ROMなどのリムーバブル媒体マウントポイント。

**** /mnt
- 
  ファイルシステムの一時マウントポイント。

**** /opt
- 
  オプションのアプリケーションソフトウェアのインストール用

**** /proc
- 
  カーネルやプロセスの情報をテキストで示す仮想ファイルシステム。
  procfs(Process File System)のマウントポイント。

**** /root
- 
  rootユーザのホームディレクトリ。オプション。

**** /sbin
- 
  システム管理系コマンドの実行ファイル群。

- 必須:
  shutdown

- オプション:
  fastboot, fasthalt, fdisk, fsck, fsck.*, getty, halt, ifconfig, init,
  mkfs, mkfs.*, mkswap, reboot, route, swapon, swapoff, update

**** /srv
- 
  システムによって提供された(served)固有のデータ

**** /tmp
- 
  一時ファイル置場。リブート時には内容が削除される。
  /var/tmpは消えない。

**** /usr
- 
  ユーザユーティリティとアプリケーションを格納。
  複数のマシンで共有可能なファイルを置き、多くのマシンにマウントして使ったりする。
  共有できないようなファイルはvarにおく。
  "User Services and Routines"の略らしい。

***** /usr/bin
- 
  一般ユーザ向けだが基本的でないコマンド。
  シングルユーザモードには不要なバイナリで、パッケージの追加削除でファイルは増減する。
  ディストリビューションが管理するディレクトリなので、自分でインストールするプログラムは/usr/local/binなどに置く。

***** /usr/include
- 
  標準includeファイル群。C言語で使う標準ヘッダファイル。
  カーネルのヘッダファイルは/usr/include/linuxと/usr/include/asmにある。
  本来は/usr/include/sys以下がカーネル関連だが、
  Linuxはカーネルとlibcで管理者が置が言うため少し変則的なディレクトリ構造になっている。

***** /usr/lib
- 
  /usr/bin や /usr/sbin にある実行ファイルの基本ライブラリ。

***** /usr/sbin
- 
  基本的でない実行ファイル群。ネットワーク用デーモンなど。
  平常時用のシステム管理コマンドやサーバプログラム。

***** /usr/share
- 
  アーキテクチャに依存しない共有データ
  典型的な例はドキュメント。manやinfoなど。

****** /usr/shar/man
- 
  manページを置く。
  roffというテキスト形式で書かれている。

****** /usr/share/info
- 
  infoドキュメントを置く。
  textinfo形式のファイルがinfo直下に並ぶ。

***** /usr/src
- 
  システムで使っているコマンドのソースコードを置く。
  Kernelのソースコードなど。

***** /usr/X11R6
- 
  X Windows System Version 11 Release 6
  下にbinやlibがある。

***** /usr/local
- 
  ホスト固有のローカルデータを格納する。システム管理者が自分でアプリケーションをインストールする。
  構造はほぼ/usrと同じ。

****** /usr/local/bin
- 
  自分でインストールするコマンド等を配置する。

****** /usr/local/games
****** /usr/local/include
****** /usr/local/lib
****** /usr/local/man
- /local/bin用マニュアル
****** /usr/local/sbin
- /sbinと比べて重要でないシステムバイナリを配置する。
  /sbinは緊急時に必要なもの、/usr/sbinは通常運用時。
****** /usr/local/share
- アーキテクチャに依存しないデータを収める。
****** /usr/local/man
******* /usr/local/man/man1
- ユーザプログラム
******* /usr/local/man/man2
- システムコール
******* /usr/local/man/man3
- Cライブラリ関数
******* /usr/local/man/man4
- スペシャル(デバイス)ファイル
******* /usr/local/man/man5
- ファイルフォーマット
******* /usr/local/man/man6
- ゲーム
******* /usr/local/man/man7
- その他
******* /usr/local/man/man8
- システム管理
****** /usr/local/misc
****** /usr/local/src


**** /var
- 
  可変なファイル群。内容が常に変化するようなファイル群を格納する。
  ログ、スプール、一時的な電子メール等。

***** /var/cache
- 
  アプリケーションのキャッシュデータ。
  普通は要領に上限を設けて、古い順に捨てていく。

***** /var/lib
- 
  状態情報。データベース、パッケージングシステムのメタデータなど。

****** /var/lib/misc

***** /var/local
***** /var/lock
- 
  ロックファイル群。使用中リソースを保持するファイル。排他制御を行いたい場合に使用する。
***** /var/log
- 
  各種ログ
***** /var/opt
***** /var/mail
- 
  メール
***** /var/run
- 
  走行中システムに関する情報。現在ログイン中のユーザ、走行中デーモン等。
  "`kill -HUP `cat /var/run/sendmail.pid`"などするとプロセス番号をタイポせずよい。
  PIDファイルともいう。

***** /var/spool
- 
  処理待ちスプール。プリントキュー、未読メールなど。

****** /var/spool/mail
- 
  互換のためのかつてのメールボックス。

***** /var/tmp
- 
  一時ファイル置場。/tmpとは異なり、リブートしても内容が失われない。

**** memo
- ディレクトリの分類
  |----------+----------------------------+---------------------|
  |          | 共有可能                   | 共有不可            |
  |----------+----------------------------+---------------------|
  | 変化せず | /usr, /opt                 | /etc, /boot         |
  |----------+----------------------------+---------------------|
  | 変化する | /var/mail, /var/spool/news | /var/run, /var/lock |
  |----------+----------------------------+---------------------|

  
*** / (何を参照したかは忘れた。)
    - vmlinuz
        Linux Kernel
    - boot
        - System.map
        - config
        - grub
        - initrd.img
          init ram disk
    - etc
        Setting Files
    - bin
        commands using by system admin and user
    - sbin
        admin tools using by system admin
    - usr
        directory which has data shared by users using the system
        - bin
        - include
        - lib
        - local
            - bin
            - etc
            - games
            - include
            - lib
            - man
            - sbin
            - share
            - src
        - sbin
        - share
    - home
    - var
        variable data
        - tmp
            directory with sticky bit, that makes the files in the directory not able to delete without the owner
        - log,spool
        - mail
        - run
            having PID in text files
        - lock
    - proc
        procfs(Process File System)
        pseudo file system giving system information
        /proc/PID/oom_score, oom_adj <-concerning with OOM Killer(Out Of Memory Killer)
    - sys
        sysfs: devise info, procfs: process and kernel info
    - dev
        deployed device files
    - tmp
        temporary
        deleted when unmounting or rebooting

** system calls
*** read(2)
- def
  #include <unistd.h>
  ssize_t read(int fd, void *buf, size_t bufsize);

- argument
  fd:ファイルディスクリプタの番号
  buf:格納先
  bufsize:最大読込バイト数

- return
  正常終了した場合は読込んだバイト数を返す。
  ファイル終端に達したときは0を、エラーが起きたときは-1を返す。

*** write(2)
- def
  #include <unistd.h>
  ssize_t write(int fd, const void *buf, size_t bufsize)

- argument
  fd:ファイルディスクリプタの番号
  buf:書込元
  bufsize:最大書込サイズ数

- return
  正常終了時は書き込んだバイト数を返す。
  エラー時は-1を返す。

*** open(2)
- def
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <fcntl.h>
  int open(const char *path, int flags);
  int open(const char *path, int flags, mode_t mode);

- argument
  path:openするファイルのパス
  flags:ストリームの性質を表すフラグ
  mode:O_CREATを指定した場合に、新規ファイルのパーミッションを指定する

  - flags 1
    常にどれか一つを指定する
    |----------+--------------|
    | O_RDONLY | 読み取り専用 |
    | O_WRONLY | 書込み専用   |
    | O_RDWR   | 読み書き両用 |
    |----------+--------------|

  - flag 2
    指定しなくても良いし、複数指定しても良い。
    下のもの以外にも色々ある。
    |----------+-----------------------------------------------------------------------------------|
    | O_CREAT  | ファイルが存在しなければ新しいファイルを作る                                      |
    | O_EXCL   | O_CREATとともに指定すると、すでにファイルが存在するときはエラーとなる             |
    | O_TRUNC  | O_CREATとともに指定すると、ファイルが存在するときはまずファイルの長さをゼロにする |
    | O_APPEND | write()が常にファイル末尾に書込まれるよう指定する                                 |
    |----------+-----------------------------------------------------------------------------------|

- return
  ファイルディスクリプタの値を返す

  - ex
    open(file, O_RDWR|O_CREAT|O_TRUNC, 0666)

*** close(2)
- def
  #include <unistd.h>
  int close(int fd);

- argument
  fd:ファイルディスクリプタ

- return
  問題なく閉じられた場合は0, エラーがあった場合は-1を返す。

- ex
  if (close(fd) < 0){
      /* エラー処理 */
  }

*** lseek(2)
- 
  ファイルディスクリプタfd内部のファイルオフセットを指定した位置offsetへ移動する。
  移動方法はwhenceに指定する。

- def
  #include <sys/types.h>
  #include <unistd.h>
  off_t lseek(int fd, off_t offset, int whence);

- argument
  whence:位置の指定方法。
         SEEK_SET:offsetに移動（起点はファイル先頭）
         SEEK_CUR:現在のファイルオフセット+offsetに移動
         SEEK_END:ファイル末尾+offsetに移動

*** dup(2), dup2(2)
- 
  oldfdを複製するシステムコール。
  dup()は使われていない最小のファイルディスクリプタへoldfdを複製してそれを返す。
  dup2()はoldfdをnewfdに複製してそれを返す。
  エラーが起きた場合は-1を返す。
  dupはduplicateから。

- def
  #include <unistd.h>
  int dup(int oldfd);
  int dup2(int oldfd, int newfd);

*** ioctl(2)
- 
  ストリームがつながる先にあるデバイスに特化した操作を全て含めたシステムコール。

- def
  #include <sys.ioctl.h>
  int ioctl(int fd, int request, ...);

- argument
  request:どのような操作をするか定数で指定し、そのrequest特有の引数を第3引数以降に渡す。

*** fcntl(2)
- 
  ファイルディスクリプタ関連の操作をioctlより分離したもの。

- def
  #include <unistd.h>
  #include <fcntl.h>
  int fcntl(int fd, int cmd, ...);

*** mkdir(2)
- 
  ディレクトリpathを作成する。
  成功したら0を返し、失敗したら-1を返してerrnoをセットする。
  第2引数には作成時のパーミッションを指定する。

- def
  #include <sys/stat.h>
  #include <sys/types.h>

  int mkdir(const char *path, mode_t mode);

- error
  - ENOENT
    親ディレクトリがない
  - ENOTDIR
    pathで親ディレクトリに当たる部分がディレクトリでない
  - EEXIST
    pathにすでにファイルやディレクトリが存在する
  - EPERM
    親ディレクトリを変更する権限がない

*** umask(2)
- 
  直前までのumaskの値をmaskに変更し、直前万でのumaskを返す。
- def
  #include <sys/types.h>
  #include <sys/stat.h>
  
  mode_t umask(mode_t mask);

*** rmdir(2)
- 
  ディレクトリpathを削除する。

- def
  #include <unistd.h>
  int rmdir(const char *path);

*** link(2)
- 
  ファイルsrcの実態に新しい名前distをつける。(ハードリンク）
  成功したときは0を返し、失敗したときは-1を返してerrnoをセットする。
  srcとdistは同じファイルシステム上に存在する必要がある。
  また、ディレクトリには使用できない。

- def
  #include <unistd.h>
  int link(const char *src, const char  *dest);

*** symlink(2)
- 
  シンボリックリンクを作成するシステムコール。
  srcを指す新しいシンボリックリンクをdestに作成する。
  成功したら0を、失敗したら-1を返す。
- def
  #include <unistd.h>
  int symlink(const char *src, const char *dest);

*** readlink(2)
- 
  readlinkは、pathの表している名前をbufに格納する。
  ただし、いかなる場合もbufsizeバイトまでしか書込まない。
  また、文字列最後の'\0'は書込まれない。
  成功したらbufに格納したバイト数を返す。失敗したら-1を返してerrnoをセットする。
- def
  #include <unistd.h>
  int readlink(const char *path, char *buf, size_t bufsize);

*** unlink(2)
- 
  名前pathを消す。成功したら0を、失敗したら-1を返す。
  ディレクトリの削除はできない。
- def
  #include <unistd.h>
  int unlink(const char *path);

*** rename(2)
- 
  srcをdestに変更する。
  成功したら0を、失敗したら-1を返してerrnoをセットする。
  ファイルシステムをまたいで移動することはできない。その場合EXDEVがerrnoにセットされる。
- def
  #include <stdio.h>
  int rename(const char *src, const char *dest);

*** stat(2)
- 
  statはpathで表されるエントリの情報を取得し、bufに書き込む。
  lstatもほとんど同じだが、シンボリックリンクの場合にリンクをたどらず自身の情報を返す。
  似たものに、ファイルディスクリプタから同じ情報を得られるfstatもある。
  成功したら0を返し、失敗したら-1を返してerrnoをセットする。

- def
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <unistd.h>

  int stat(const char *path, struct stat *buf);
  int lstat(const char *path, struct stat *buf);

- struct statメンバ
  |-----------+------------+--------------------------------------------|
  | 型        | メンバ名   | 説明                                       |
  |-----------+------------+--------------------------------------------|
  | dev_t     | st_dev     | デバイス番号                               |
  | ino_t     | st_ino     | iノード番号                                |
  | mode_t    | st_mode    | ファイルタイプとパーミッションを含むフラグ |
  | nlink_t   | st_nlink   | リンクカウント                             |
  | uid_t     | st_uid     | 所有ユーザID                               |
  | gid_t     | st_gid     | 所有グループID                             |
  | dev_t     | st_rdev    | デバイスファイルの種別を表す番号           |
  | off_t     | st_size    | ファイルサイズ（バイト単位）               |
  | blksize_t | st_blksize | ファイルのブロックサイズ                   |
  | blkcnt_t  | st_blocks  | フロック数                                 |
  | time_t    | st_atime   | 最終アクセス時刻                           |
  | time_t    | st_mtime   | 最終変更時刻                               |
  | time_t    | st_ctime   | 付帯情報が最後に変更された時期             |
  |-----------+------------+--------------------------------------------|

*** chmod(2)
- 
  pathのモードをmodeに変更する。
  成功したら0を返し、失敗したら-1を返してerrnoをセットする。

- def
  #include <sys/types.h>
  #include <sys/stat.h>
  
  int chmod(const char *path, mode_t mode)

*** chown(2)
- 
  pathの所有ユーザをownerに、所有グループをgroupに変更する。
  ownerはユーザID, groupはグループID。
  どちらかだけを変更したい場合、変更しない値を-1とする。
  lchownは、pathがシンボリックリンクだった場合はシンボリックリンク自体の情報を変更する。
  成功したら0を返す。失敗したら-1を返し、errnoを設定する。
  所有ユーザを変更する場合はスーパーユーザ権限が必要。
  所有グループを変更する場合はファイルの所有ユーゼでかつ自分がgroupに含まれる必要がある。
  スーパーユーザならば任意のグループに変更可能。

- def
  #include <sys/types>
  #include <unistd.h>
  
  int chown(const char *path, uid_t owner, gid_t group);
  int lchown(const char *path, uid_t owner, gid_t group);

*** utime(2)
- 
  pathの最終アクセス時刻(st_atime)と最終更新時刻(st_mtime)を変更する。
  bufがNULLでなければ最終アクセス時効をbuf->actime, 最終更新時刻をbuf->modtimeに変更する。
  bufがNULLなら両方を現在時刻に変更する。
  成功したら0を返し、失敗したら-1を返しerrnoを設定する。

- def
  #include <sys/types.h>
  #include <utime.h>
  
  int utime(const char *path, strut utimbuf *buf);
  
  struct utimbuf {
      time_t actime; /* 最終アクセス時刻 */
      time_t modtime; /* 最終更新時刻 */
  }

*** mmap(2)
- 
  ファイルやデバイスをメモリにマップ/アンマップする
  ファイル記述子fdで指定されたファイルの、オフセットoffsetからlengthバイトの範囲を
  メモリにマップする。
  このとき、なるべくメモリ上のaddrアドレスからはじめるようにマップする。
  実際には関数に対してのヒントでしかなく、通常は0を選択する。
  protは、メモリ保護をどのように行うか指定する。
  flagsは、マップされたオブジェクトのタイプ、マップ時のオプション、
  マップされたページコピーへの変更をそのプロセスだけが行えるのか指定する。

- def
  #include <sys/mman.h>
  void *mmap(void *addr, size_t length, int prot, int flags,
             int fd, off_t offset);
  int munmap(void *addr, size_t length);

- plot
  |------------+--------------|
  | フラグ名   | 内容         |
  |------------+--------------|
  | PROT_EXEC  | 実行可能     |
  | PROT_READ  | 読み込み可能 |
  | PROT_WRITE | 書き込み可能 |
  | PROT_NONE  | アクセス不能 |
  |------------+--------------|

- return
  - mmap
    成功するとマップされた領域へのポインタを返す。
    失敗すると値MAP_FAILED((void *)-1)を返し、errnoがセットされっる。
  - munmap
    成功すると0を返し、失敗すると-1を返しerrnoがセットされる（多くの場合EINVAL）。

*** brk(2)
- 
  物理アドレスが割り当てられていないページに物理アドレスを対応させる。
  malloc(3)やrealloc(3)が使っているシステムコール。
  sbrk(2)というシステムコールもある。

*** fork(2)
- 
  プロセスを複製し、2つのプロセスに分裂させる。
  両方のプロセスでfork()の呼び出しが戻る。
  元から存在しているほうを親プロセス、複製した方を子プロセスという。
  子プロセスでの戻り値は0で、親プロセスの戻り値は子プロセスのプロセスIDとなる。
  失敗した場合は子プロセスは作成されず、親でのみ-1が戻る。

- def
  #include <sys/types.h>
  #include <unistd.h>
  pid_t fork(void);

*** exec(2)
- 
  現在実行してるプロセスが消滅し、自プロセスに新しいプログラムをロードする。
  execは成功すると呼び出しが戻らないので、戻った場合は常に失敗。-1を返してerrnoをセットする。
  - l
    語尾に"l"がつくものは、コマンドライン引数を引数リストとして渡す。
    引数リストの最後はNULLを置かなければならない。
  - v
    コマンドライン引き巣を文字列の配列で渡す。argv[]の最後の要素はNULLにしなければならない。
  - e
    最後の引数として環境変数envpが追加される。
    eがついていないAPIでは、現プロセスの環境変数がそのまま使われる。
  - p
    第1引数programを環境変数PATHから自動で探す。
    pがついていない場合、常にpathを絶対パスまたは相対パスで指定しなければならない。

- def
  #include <unistd.h>

  int execl(const char *path, const char *arg, ... /* NULL */);
  int execlp(const char *program, const char *arg, ... /* NULL */);
  int execle(const char *path, const char *arg, ... /* NULL, */
             char * const envp[]);
  int execv(const char *path, char * const argv[]);
  int execvp(const char *program, char * const argv[]);
  int execve(const char *path, char * const argv[],
             char * const envp[]);

*** wait(2)
- 
  waitは子プロセスのうちどれかひとつが終了するのを待つ。
  waitpidはpidで指定したプロセスが終了するのを待つ。
  statusにNULL以外を指定した場合、そのアドレスに子プロセスの終了ステータスが格納される。

- def
  #include <sys/types.h>
  #include <sys/wait.h>
  
  pid_t wait(int *status);
  pid_t waitpid(pid_t pid, int *status, int options);

- 終了の仕方を調べるマクロ

  |---------------------+----------------------------------------------------|
  | マクロ              | 意味                                               |
  |---------------------+----------------------------------------------------|
  | WIFEXITED(status)   | exitで終了していたら非0、それ以外なら0             |
  | WEXITSTATUS(status) | exitで終了し手いたときに、その終了コードを返す。   |
  | WIFSIGNALED(status) | シグナルで終了したら非0、それ以外なら0             |
  | WTERMSIG(status)    | シグナルで終了したときに、そのシグナル番号を返す。 |
  |---------------------+----------------------------------------------------|

*** _exit(2)
- 
  statusを終了ステータスとしてプロセスを終了する。
  絶対に失敗しないので、呼び出したら戻らない。
  exit(3)と異なりlibc関連の後始末を行わない。

- def
  #include <unistd.h>
  void _exit(int status);

*** pipe(2)
- 
  両端とも自プロセスにつながったストリームを作成し、その両端のディスクリプタを返す。
  

- def
  #include <unistd.h>
  int pipe(int fds[2]);

*** getpid(2), getppid(2)
- 
  getpid()は自分のプロセスIDを返す。
  getppid()は親プロセスのppidを返す。

- def
  #include <sys/types.h>
  #include <unistd.h>
  pid_t getpid(void);
  pid_t getppid(void);

*** setsid(2)
- 
  新しいセッションを作成し、自分がセッションリーダーになる。
  同時にそのセッションで最初のプロセスグループを作成し、そのグループリーダーとなる。
  戻り値は作成したセッションID。失敗した場合は-1を返しerrnoをセットする。
  失敗する多くの場合は、自分がプロセスグループリーダーの場合なので、
  あらかじめ1回多くforkしておいてグループリーダーではなくなっている必要がある。
  制御端末を持たないため、デーモンとなる。

- def
  #include <unistd.h>
  pid_t setsid(void);

*** signal(2)
- 
  signalを捕捉するAPI。
  シグナルを送るAPIでなくtrapするAPIなので注意。
  
  シグナル番号sigのシグナルを受けたときの挙動を、
  第2引数funcの関数を呼ぶように変更する。
  このfuncに渡す関数を、シグナルを処理する関数という意味でシグナルハンドラ(signal handler)と呼ぶ。

  問題が色々とあるため、sigaction()を用いるのがよい。

- def
  #include <signal.h>
  void (*signal (int sig, void (*func)(int)))(int)

  (わかりにくいので少し書き直すと↓
   typedef void (*sighandler_t)(int);
   sighandler_t signal(int sig, sighandler_t func);
  )

- 第2引数funcで用いられる特別な値
  |---------+--------------------------------------------------|
  | 定数    | 意味                                             |
  |---------+--------------------------------------------------|
  | SIG_DFL | OSのデフォルトの動作に戻す                       |
  | SIG_IGN | カーネルレベルでシグナルを無視するように指示する |
  |---------+--------------------------------------------------|

*** sigaction(2)
- 
  sigaction()は第1引数のシグナルsigのハンドラを登録する。
  第2引数actにシグナルハンドラを指定する。具体的には関数ポインタかSIG_IGN, SIG_DFL。
  第3引数のoldactには、sigaction()呼び出し時のハンドラが返る。不要ならNULLを指定する。
  struct sigcationのsa_sigcationもシグナルハンドラを指定するメンバで、
  受信したときにシグナル番号以外の情報を得ることが出来る。
  
- def
  #include <signal.h>
  
  int sigaction(int sig, const struct sigaction *act,
                struct sigaction *oldact);
  
  struct sigaction {
      /* sa_handler, sa_sigactionは片方のみ使う */
      void (*sa_handler)(int);
      void (*sa_sigaction)(int, siginfo_t*, void*);
      sigset_t sa_mask;
      int sa_flags;
  };

- signalの問題点に対する対処
  - ハンドラの再設定
    sigaction()はOSに関わらずシグナルハンドラの設定を保持し続けることを保証する。
  - システムコールの再起動
    sigaction()はデフォルトでシステムコールを再起動しない。
    sa_flagsメンバにフラグSA_RESTARTを追加すると再起動する設定になる。
    一般には再起動されるほうが便利なので、SA_RESTARTを常に追加しておくのが無難。
  - シグナルのブロック
    sa_maskでブロックするシグナルを指定できる。
    シグナルハンドラの起動中は処理中のシグナルを自動的にブロックしてくれるので、
    ほとんどの場合はsa_maskは空にしておけば十分。空にするにはsigemptyset()を使う。

- sigset_t操作API
  - int sigemptyset(sigset_t *set);
    setを空に初期化する
  - int sigfillset(sigset_t *set);
    setをすべてのシグナルを含む状態にする
  - int sigaddset(sigset_t *set, int sig);
    シグナルsigをsetに追加する
  - int sigdelset(sigset_t *set, int sig);
    シグナルsigをsetから削除する
  - int sigismember(const sigset_t *set, int sig);
    シグナルsigがsetに含まれるとき真をかえす

- シグナルのブロック
  ブロックしていたシグナルを配送してもらうためのAPI。
  sigprocmaskは自プロセスのシグナルマスクをセットする。
  セット方法はフラグhowで決まる。
  sigpendingは保留されているシグナルをsetに書き込む。
  成功したら0、失敗したら-1を返しerrnoをセットする。
  sigsuspendはシグナルマスクmaskをセットすると同時にプロセスをシグナル待ちにする。
  ブロックしていたシグナルを解除して、保留されていたシグナルを処理するときに使う。
  sigsuspendは常に-1をかえす。

  - def
    #include <signal.h>
    
    int sigprocmask(int how, sigset_t *set, sigset_t *oldset);
    int sigpending(sigset_t *set);
    int sigsuspend(const sigset_t *mask);

  - sigprocmaskのhow値
    |-------------+---------------------------------------------------|
    | 値          | 効果                                              |
    |-------------+---------------------------------------------------|
    | SIG_BLOCK   | setに含まれるシグナルをシングルマスクに追加する   |
    | SIG_UNBLOCK | setに含まれるシグナルをシグナルマスクから削除する |
    | SIG_SETMASK | シグナルマスクをsetに置き換える                   |
    |-------------+---------------------------------------------------|

*** kill(2)
- 
  シグナルを送信するシステムコール。
  プロセスIDがpidのプロセスにシグナルsigを送信する。
  成功したら0を返す。失敗したら-1を返し、errnoをセットする。
  pidが負数のときは、IDが-pidのプロセスグループ全体にシグナルを送る。
  プロセスグループにシグナルを送るには、killpg()という専用のシステムコールもある。

- def
  #include <sys/types.h>
  #include <signal.h>
  
  int kill(pid_t pid, int sig);

*** chdir(2)
- 
  自プロセスのカレントディレクトリをpathに変更する。
  成功したら0、失敗したら-1を返しerrnoをセットする。

- def
  #include <unistd.h>
  int chdir(const char *path);

*** getuid(2), getgid(2)
- 
  現在のクレデンシャルを得る。
  getuidは実ユーザIDを、geteuidは実行ユーザIDを、
  getgidは実グループIDを、getegidは実行グループIDを、
  それぞれ返す。
  これらのシステムコールは失敗しない。

- def
  #include <unistd.h>
  #include <sys/types.h>
  
  uid_t getuid(void);
  uid_t geteuid(void);
  gid_t getgid(void);
  gid_t getegid(void);

*** getgroups(2)
- 
  自プロセスの捕捉グループIDをbufに書き込む。
  捕捉グループIDがbufsize個より多い場合は、エラーを返す。
  成功した場合捕捉グループIDの数を、失敗した場合は-1を返してerrnoをセットする。

- def
  #include <unistd.h>
  #include <sys/types.h>
  
  int getgroups(int bufsie, gid_t *buf);

*** setuid(2), setgid(2)
- 
  setuid()は、実ユーザIDと実行ユーザIDをidに変更する。
  setgid()は、実グループIDと実行グループIDをidに変更する。
- def
  #include <unistd.h>
  #include <sys/types.h>
  
  int setuid(uid_t id);
  int setgid(gid_t id);

*** initgroups(2)
- 
  /etc/groupなどのデータベースを見て、
  ユーザuserの補足グループを自プロセスに設定する。
  また、第2引数のgroupも追加する。
  groupは通常、ユーザのグループ(primary group)を補足グループにも追加するために使う。
  成功したら0を返す。失敗したら-1を返しerrnoを設定する。
  スーパーユーザでないと成功しない。

- def
  #define _BSD_SOURCE
  #include <grp.h>
  #include <sys/types.h>
  
  int initgroups(const char *user, gid_t group);

*** getrusage(2)
- 
  プロセスのリソース使用量を第2引数usageに書き込む。
  第1引数whoがRUSAGE_SELFならば自プロセスのリソース使用量を書き込む。
  第1引数whoがRUSAGE_CHILDRENならば子プロセスのリソース使用量を書き込む。
  この場合の子プロセスは「自プロセスからfork()した子プロセス全てのうち、waitしたもの」を意味する。
  呼び出しが成功したら0を返す。失敗したら-1を返してerrnoをセットする。

- def
  #include <unistd.h>
  #include <sys/resource.h>
  #include <sys/time.h>
  
  int getrusage(int who, struct rusage *usage);

- struct rusage
  「man getrusage」には沢山のメンバがあるが、
  Linuxではそのうちの一部しか正しい値がセットされない。
  
  |----------------+-----------+--------------------------|
  | 型             | メンバ名  | 意味                     |
  |----------------+-----------+--------------------------|
  | struct timeval | ru_utime  | 使われたユーザ時間       |
  | struct timeal  | ru_stime  | 使われたシステム時間     |
  | long           | ru_majflt | メジャーフォールトの回数 |
  | long           | ru_minflt | マイナーフォールトの回数 |
  | long           | ru_nswap  | スワップサイズ           |
  |----------------+-----------+--------------------------|

*** time(2)
- 
  UNIXエポックから現在までの経過秒数を返す。
  tptrがNULLでない場合は*tptrにも同じ値を書き込む。
  秒までの単位しか扱えない。

- def
  #include <time.h>
  time_t time(time_t *tptr);

*** gettimeofday(2)
- 
  UNIXエポックから現在までの経過時間をtvに書き込む。
  tzは既に使われていないので常にNULLを指定する。
  実行が成功したら0を返し、失敗したら-1を返しerrnoをセットする。

- def
  #include <sys/time.h>
  
  int gettimeofday(struct timeval *tv, struct timezone *tz);
  
  struct timeval {
      long tv_sec;   /* 秒 */
      long tv_usec;  /* ミリ秒 */
  };

** command

*** mv
- 
  リネームとかファイルの移動とか。
  mv aaa{,bbb}とするとaaa->aaabbbにリネームされる。

*** touch
*** mkdir
*** rmdir

*** rm
- 
  ファイルを削除する

*** chmod
- 
  アクセス権限の変更。

  u:所有者 g:グループ o:その他すべて a:すべての権限
  +:権限付与 -:権限削除 =:権限の書き換え
  r:読み込み w:書き込み x:実行 s:セットID t:スティッキービット

  - SUID
    SUID(Set User ID)は特殊なパーミッションのひとつで、
    実行可能ファイルに設定する。
    実行権にRootユーザのユーザIDをセットできる。
    u+s, 4xxx
  - SGID
    SGID(Set Group ID)は特殊なパーミッションのひとつで、
    実行可能ファイルおよびディレクトリに設定する。
    実行権にGroupのグループIDをセットできる。
    g+s, 2xxx
  - スティッキービット
    特殊なパーミッションのひとつで、ディレクトリに対して設定する。
    書き込み権限があっても、自分以外のユーザが所有するファイルを削除できなくなる。
    o+t, 1xxx

*** chgrp

*** tail
- 
  n:number f: follow (exit with C-c)

*** ls

*** read
- [varname]
  標準入力から1行読み取り、読み込んだ内容をvarnameに指定したシェル変数に格納する。

*** echo
- 
  メッセージを表示する

*** printf
- 
  メッセージを整形して表示する。
  '\n'を入れないと改行されない。

*** man

- マニュアルを呼び出す。
  |------------+------------------------|
  | セクション | 分類                   |
  |------------+------------------------|
  |          1 | ユーザコマンド         |
  |          2 | システムコール         |
  |          3 | ライブラリ関数         |
  |          4 | デバイスファイルなど   |
  |          5 | ファイルフォーマット   |
  |          6 | ゲーム                 |
  |          7 | 規格など               |
  |          8 | システム管理用コマンド |
  |------------+------------------------|

*** info
- 
  emacsを使ってマニュアルを表示する。
  GNU libcの一次情報はinfo。

*** apropos
- 
  show result searched from summaries and command names.
  whatisデータベースより文字列を検索する。

*** whatis
- 
  show summary of man, searched from command names.
  簡単な説明とキーワードを含むデータベースを検索し、結果を出力する。

*** whereis
- 
  コマンドのバイナリ、ソース、manページの場所を示す。

*** which
- 
  コマンドのフルパスを表示する。パスが通っているもののみ。
  （パスが通っていないものについては、findやlocateを使用するとよい。）

*** who
- 
  現在ログインしているユーザ情報を表示する

*** w
- 
  ログインユーザ名とその利用状況を表示する。

*** type
- 
  コマンドに関する情報を表示する
- -a
  コマンドのパス名として、実際に起動されるパス以外にその他のパスも表示する。
- -p
  コマンド名を指定した場合に、実行されるファイル名を表示する。
- -t
  コマンドの型を表示する
  alias, shell builtin, file, function, keywordがある。

*** file
- 
  実行可能ファイルかテキストかその他データかなどのファイルのタイプを判定して表示する。
- -b
  簡易モードで表示する。
- -i
  ファイルをmimeタイプ文字列にする。
- -z
  圧縮ファイルの中も調べる
- -v
  バージョンを表示する

*** ldd
- 
  共有ライブラリの依存関係を表示する。

*** clear

*** ps
- 
  実行中のプロセスを表示する。
- -a
  自分以外のユーザのプロセスも表示する
- -x
  制御端末のないプロセスの情報も表示する
- -e
  全てのプロセスを表示する。
- -f
  プロセスの親子関係を表示する

*** pstree
- [ pid | user ]
  実行中のプロセスをツリー形式で実行する。
  pidを基点として表示するが、省略されるとinitを基点とする。

*** pgrep
- 
  選択基準にマッチするプロセスのプロセスIDを標準出力する
- -l
  プロセス名をプロセスIDと一緒に表示する
- -o
  マッチしたプロセスの中から最古のものを表示する
- -U ユーザID
  ユーザIDがリストのどれかであるプロセスを表示する
- -G グループID
  実グループIDがリストのどれかであるプロセスのみマッチする
  
*** kill
- [-s signal] pid
  プロセスおよびジョブを強制終了する
- -l
  シグナルの一覧を表示する
  |----+---------+--------------------------------------------------------------------------------|
  |  1 | SIGHUP  | 端末との接続が切断された(Hangup)ことによるプロセスの終了                       |
  |  2 | SIGINT  | キーボードからの割り込み(Interrupt)によるプロセスの終了                        |
  |  3 | SIGQUIT | キーボードからの中止(Quit)                                                     |
  |  4 | SIGILL  | 不正な命令(Illegal instruction)によるプロセスの終了                            |
  |  5 | SIGTRAP | トレース(Trace),ブレークポイントとラップ(break point trap)によるプロセスの終了 |
  |  6 | SIGABRT | abrot関数によるプロセスの中断                                                  |
  |  8 | SIGFPE  | 浮動小数点例外(Arithmetic Exception)によるプロセスの終了                       |
  |  9 | SIGKILL | Killシグナルによるプロセスの終了                                               |
  | 11 | SIGSEGV | 不正なメモリー参照(Segmentation fault)によるプロセスの終了                     |
  | 13 | SIGPIPE | パイプ(Pipe)破壊によるプロセスの終了                                           |
  | 14 | SIGALRM | alerm関数によるプロセスの終了                                                  |
  | 15 | SIGTERM | 終了(Termination)シグナルによるプロセスの終了                                  |
  |----+---------+--------------------------------------------------------------------------------|

*** trap
- 
  システム割り込み時の処理を設定する。
- -l
  シグナル名と対応する番号の一覧を表示する
- -p
  単独で用いた場合、現在各シグナルに対して設定されている処理内容を表示する。

*** mount
- 
  現在マウントされているファイルシステムを調べる。
- --bind
  すでにマウントされているツリーの一部を別の場所にマウントする。
- -v verbose
- -t
  ファイルシステムのタイプを指定
   ext3, ntfs, sysfs, devpts, proc, tmpfsなど。

*** unmount

*** sysctl
- 
  system settings
  /proc/sys/net/ipv4/ip_forward -> net.ipv4.ip_forward (in /etc/sysctl.conf)

*** fdisk
- 
  パーティションを設定する。
  [- l] リストを取得する。 (sudo fdisk -l /dev/sda)

*** dmesg
- 
  カーネルのメッセージバッファの内容を表示する。"display message"の略。

*** df
- 
  ファイルシステムについて、使用領域と空き領域のサイズを表示する。
  disk free : display free disk space.
  [-h] サイズの単位をつけてくれる。
  [-a] サイズが0のファイルシステムも出力
  [-T] ファイルシステムの種類(ex: ext4)も出力

*** mkfs
- 
  ファイルシステムの作成
- -t
  ファイルシステムタイプを指定する。
- -V
  verboseもversionも兼用しているようです。
  ex: mkfs -v -t ext4 /dev/sdb1

*** mkswap
- 
  スワップ領域を設定する。
  mkswap /dev/sbd2

*** export
- 
  変数を大域変数として追加する。
  export FOO="BAR"

*** ln
- 
  リンクを作成する
- -s, --symbolic
  シンボリックリンクの作成
- -v, --verbose

*** groupadd
- 
  新しいグループの作成

*** useradd
- 
  新規ユーザの作成
- -s
  shellを設定する。
- -g 
  主グループを設定する。
- -m
  ホームディレクトリが存在しない場合に作成する。
- -k
  -mと同時に指定すると、指定したフォルダ以下のファイルがコピーされる。
  指定しない場合は/etc/skel以下をコピー。

*** passwd
- 
  ユーザパスワードを変更する。

*** chown
- 
  所有者を変更する。
- -v verbose

*** su
- 
  ユーザを切り替える。
- -, -l, --login 
  シェルをログインシェルにする。

*** source
- 
  "source filename"で、filenameで指定されたスクリプトファイルを実行する。
  ファイルの内容を、自分で手で打っていくのと同じ
*** tar
- 
  ファイルを書庫化、展開する。
  - メインオプション
    - -A, --catenate
      tarファイルを書庫に追加する
    - -c, --create
      書庫を新規作成する
    - -d, --diff
      書庫とファイルシステム比較する
    - --delete
      書庫内からファイルを削除する
    - -r, --append
      書庫の後部にファイルを追加する
    - -t, --list
      書庫の内容を表示する
    - -u, --update
      新しいファイルのみ追加する
    - -x, --extract
      書庫内からファイルを取り出す
  - その他
    - -f
      ファイルを指定
    - -v, --verbose
      ファイル一覧を詳細に表示
  - 形式別(最近は自動判断)
    - -z
      tar + gzip
    - -j
      tar + bzip2
    - -J
      tar + xz

*** zip / unzip
*** rar / unrar
*** gzip / gunzip
*** bzip2 / bunzip2
*** xz / unxz

*** readelf
    ELFファイルに関する情報を表示

*** make
    コンパイル等の処理を自動で行う。
    [-k, --keep-going] エラーが発生してもできるだけ処理を継続させる。
    [-n, --just-print, --dry-run] 実際には処理せず実行コマンドのみ表示する。

*** tee
    標準入力から読み込んだ内容を、標準出力とファイルの両方へ出力する。

*** find
- 
  ファイルやディレクトリを検索する。
  用法: find [option] [path...] [expression]
- -name
  ファイル名を検索、パターンマッチ可。
- -exec
  検索後コマンドを実行する。

*** locate
- 
  ファイルを高速に検索する。
  あらかじめ作成したデータベースを用いるため、findコマンドより高速。
  データベースはスーパーユーザ権限でupdatedbコマンドを実行して作成する。

*** updatedb
- 
  locate用ファイル・データベースを更新する。

*** strip
    オブジェクトファイルからシンボル(デバッグ用のデータ)を切り捨てる。

*** mknod
    特殊ファイルを作成する。
    mknod [オプション] ファイル名 タイプ メジャー マイナー
    [-m] アクセス権を設定する。デフォルトは0666からumaskを引いたもの。
    タイプ: b ブロック(buffered)型、c,u キャラクタ(unbuffered)型
            p FIFO(名前つきパイプ)
            ※pを指定を指定した場合はデバイス番号（メジャーマイナー）を指定しない。

*** chroot
    ルートディレクトリを変更してコマンドを実行する。
    chroot directory [command [args]]

*** install
    ファイルをコピーして属性の設定をする。
    1. install [OPTION]... SOURCE DEST
    2. install [OPTION]... SOURCE... DIRECTORY
    3. install -d [OPTION]... DIRECTORY...
    [-d, --directory] ディレクトリを作成する。
    [-m, --mode] アクセス権を設定する。
    [-v, --verbose]

*** tzselect
    タイムゾーンを選択する。

*** readlink
    シンボリックリンクの値を読む。
    readlink [OPTION]... FILE...

*** gcc
- 
  コンパイルする。
- -o
  ファイル名を指定する。
  ex) gcc -o hello.exe hello.c
- -Wall
  ANSI Cスタイルの宣言と定義を使った場合に、一般的な警告オプションがすべてOnになり、
  細かな警告をしてくれる。
- -O1(O), -O2, -O3
  最適化オプション。数字が大きい方が強力な最適化が行われる。
  ただしO3はバグが多い印象があるとのこと。
- -g
  gdbでのデバッグが可能となる。
- -E
  プリプロセスだけ処理して標準出力する
- -S
  コンパイルまでを行いアセンブリファイルを出力する
- -c
  アセンブルまで行いオブジェクトファイルを出力する
- -l
  ダイナミックリンクを行う。
  引数としてメイン関数を先、ライブラリを後に並べる必要ある。
  -lの後にスペースはあけず、ライブラリ名のlibを除いたものを指定する。
  ex) libmをリンクしたければ、-lmとする。

*** gdb
- 
  デバッグを行う。
- run (options)
  プログラムを開始する。オプションをつけるとオプション付きで実行する。
- backtrace, bt
  バックトレースを表示する。呼び出し順の逆に列挙される。
- frame N, f
  フレームNに飛ぶ。
  （番号を指定することで、backtraceで確認した番号の処理に飛べる。）
- list, l
  現在の関数のソースコードを表示する。
- print EXPR, p
  式EXPRの値を表示する
- continue, c
  続きを実行する
- quit, q
  gdbの終了する

*** strace
- 
  動作中のプログラムが呼んだシステムコールを表示してくれる。

*** fg
- [%jobsid]
  バックグラウンドで実行しているジョブをフォアグラウンドに切り替える。

*** bg
- [%jobsid]
  ジョブをバックグラウンドで実行するよう切り替える。

*** jobs
- 
  実行中のジョブを表示する。

*** stop
- [%jobsid]
  バックグラウンドで停止するコマンドのジョブ番号を指定する

*** sh(dash)
- 
  'sh -c -x "コマンド内容"'などととすることで、
  シェルがどのようにコマンドを展開しているか理解するのに役立つ。

- -c
  Read commands from the command string operand instead of from the standard input.
  
- -x xtrace
  Write each command to standard error befor it is executed. Useful for debugging.

*** top
- 
  CPUのプロセスをリアルタイムで表示する。
- 
  |----------+-----------------------------------------------|
  | 表示項目 | 説明                                          |
  |----------+-----------------------------------------------|
  | PID      | プロセスID                                    |
  | USER     | プロセスを実行しているユーザ名                |
  | PRI      | 優先度                                        |
  | NI       | ナイス値                                      |
  | SIZE     | 仮想イメージの大きさ                          |
  | RSS      | 使用中の物理メモリー量                        |
  | SHARE    | 使用中の共有メモリー量                        |
  | STAT     | プロセスのステータス。                        |
  |          | Rは実行可能、Sは停止、Dは割り込み不可の停止、 |
  |          | Tは停止またはトレース中、Zはゾンビプロセス、  |
  |          | Wはスワップアウトしたプロセス、               |
  |          | Nはナイス値が正であることを表す               |
  | LIB      | ライブラリが使用するページサイズ              |
  | %CPU     | CPU占有率                                     |
  | %MEM     | メモリー占有率                                |
  | TIME     | プロセス開始からの実行時間                    |
  | COMMAND  | タスクのコマンド名                            |
  |----------+-----------------------------------------------|

*** exec
- 
  現在実行中のシェルに変わり、指定したコマンドを実行する。
  コマンドを実行すると普通forkして子プロセスを生成するが、
  execから呼ぶとforkせずコマンドが呼ばれる。

*** export
- 
  環境変数を設定する。

- -n
  指定した環境変数を削除する

- -p
  環境変数の一覧を取得する

*** unset
- 
  指定した変数や関数を削除する。
  ただし、シェルが始めから利用している変数や
  readonlyが指定されている変数は削除できない。

*** tty
- 
  どの端末が割り当てられたか確認する

*** exit
- 
  スクリプトの実行を終了する。
  returnと異なり、関数がどれだけネストしていても全体が終了される。
  数字を指定して終了ステータスを返すことが出来る。

*** return
- 
  関数の実行を終了する。
  数字を指定して終了ステータスを返すことが出来る。

*** stty
- 
  端末ラインの設定を変更・表示する
- -a
  すべてのオプション設定の現在の状態を標準出力に書き出す

*** joke
**** sl
- 
  slが走る。いくつかオプションも存在する。

**** banner
- 
  バナーっぽいアスキーアートが表示できる。

**** aafire
- 
  AAの炎が表示される。

**** cmatrix
- 
  matrixっぽい表示

** memo
*** suid
- 
  set user id。
  コマンドを実行するユーザに関係なく特定のユーザで実行したいときに、
  ファイルパーミッションのset-uidビット(set-user-ID bit)を立てておくと、
  起動したユーザに関わらず、ファイルのオーナー権限で起動される。
  パーミッションのxがsと表示される。
  setuid()システムコールとは何の関係もない。
-
  起動ユーザIDを実ユーザID(real user ID)、
  オーナーIDを実行ユーザID(effective user ID)という。

*** sgid
- 
  set group id。
  suidとほとんど同じなのでそちらを参照。

- 
  起動ユーザグループIDを実グループID(real group ID)、
  プログラム所有グループIDを実行グループID(effective group ID)という。

*** /etc/passwd
    ユーザ名:暗号化パスワード:UID:GID:ユーザのフルネーム:ユーザのホームディレクトリ:ログインシェル

*** /etc/group
    グループ名:パスワード:GID:ユーザアカウントのリスト(カンマ区切り)

*** /etc/nsswitch.conf
    ネームサービススイッチ(NSS)の設定ファイル。
    いろいろなカテゴリの名前サービス情報を、どの情報源からどの順序で取得するかを判断するのに使用される。
  
*** heredoc
- 
  ヒアドキュメント。
  << の後にデリミタとなる識別子を続け、最初に指定した識別子だけの行がくるまで入力が続く。
  
  - 行頭を<<-ではじめることで、行頭のタブが無視され、インデントを崩さずヒアドキュメントを書ける。
  - デフォルトでは、変数展開やバッククオートのコマンド展開が行われる。($PWD等)
  - デリミタを引用符で囲むことで(<< "EOF")、コマンド展開等を無効にできる。

- ex:)
    cat > ~/.bashrc << "EOF"
    set +h
    unmask 022
    EOF

*** Ctrl-s
    スクロール停止キー。画面がフリーズしたように見える。
    ログを見ていて、一時的にとめておくために使ったりする。
    解除はCtrl-q
*** glob
- 
  シェルが*?{}[]~などを解釈し、ファイル名として展開することをグロブ（ファイルグロブ）という。
  正規表現とは別物。
  働かせたくない場合は""等で囲む。
  ちなみにWindowsではLinuxと異なりプログラム側で展開する。
*** tty
- 
  端末を表すttyは、TeleTYpeの略。

*** standard input/output
- 
  |----------------+---------------+--------+----------------|
  | FileDiscriptor | Macro         | stdio  | Meaning        |
  |----------------+---------------+--------+----------------|
  |              0 | STDIN_FILENO  | stdin  | 標準入力       |
  |              1 | STDOUT_FILENO | stdout | 標準出力       |
  |              2 | STDERR_FILENO | stderr | 標準エラー出力 |
  |----------------+---------------+--------+----------------|

*** sys/types.h システム定義型
OSやCPUの差異を隠蔽するために別名で基本型を再定義している。
- size_t
  符号なし整数型
- ssize_ti
  符号付き整数型

*** '\0'の有無
- 
  read(2)は終端に'\0'を想定していない。
  対して、printf()は末尾に'\0'を前提としているので、
  そのまま渡したり、合わせて使うのは間違い。
*** ミドルウェアのユーザ
- 
  Apacheなどのミドルウェアに対し、専用のユーザを作成することが多いが、
  セキュリティ対策としてログインシェルを無効化しておくことが多い。
  ログインシェルを無効化するには、そのユーザのログインシェルとして無効なファイルを指定する。
  そうすると、ログインを試みた場合に自動でログアウトされる。
  /bin/falseなどに設定しておく。

*** signal
- 
  実行中のプロセスに対し、さまざまなイベントを通知するために送出されるもの。
  SIGTERMやSIGKILLの他にも数十種類存在する。
  "kill -l"で参照可能。
  killコマンドでシグナルの送信が可能。
  また、シグナルを受信して処理するにはtrapコマンドが使える。

- よく使われるシグナル
  |------------------+------+------------+--------------------------------------------------------------------------------------------|
  | デフォルトの名前 | 補足 | 挙動       | 生成原因と用途                                                                             |
  |------------------+------+------------+--------------------------------------------------------------------------------------------|
  | SIGINT           | ○   | 終了       | 割り込み。Ctr+Cで生成され、中止したいときに使う。                                          |
  | SIGHUP           | ○   | 終了       | ユーザがログアウトしたときなどに生成、デーモンでは設定ファイルの読み直しに使う場合が多い。 |
  | SIGPIPE          | ○   | 終了       | 切れたパイプに書き込むと生成される。                                                       |
  | SIGTERM          | ○   | 終了       | プロセスを終了させるときに使う。killのデフォルト値。                                       |
  | SIGKILL          | ×   | 終了       | 確実にプロセスを終了させるために使う                                                       |
  | SIGCHLD          | ○   | 無視       | 子プロセスが停止または終了したときに生成される                                             |
  | SIGSEGV          | ○   | コアダンプ | アクセスが禁止されているメモリ領域にアクセスした。                                         |
  | SIGBUS           | ○   | コアダンプ | アラインメント違反。ポインタ操作を間違えたときに生成される。                               |
  | SIGFPE           | ○   | コアダンプ | 算術演算エラー。ゼロ除算や不動小数点数オーバーフローなど。                                 |
  |------------------+------+------------+--------------------------------------------------------------------------------------------|

*** ファイルの種類を判定するマクロ
- 
  |----------+----------------------------------|
  | マクロ名 | 効果                             |
  |----------+----------------------------------|
  | S_ISREG  | 普通のファイルなら非ゼロ         |
  | S_ISDIR  | ディレクトリなら非ゼロ           |
  | S_ISLNK  | シンボリックリンクなら非ゼロ     |
  | S_ISCHR  | キャラクタデバイスなら非ゼロ     |
  | S_ISBLK  | ブロックデバイスなら非ゼロ       |
  | S_ISFIFO | 名前付きパイプ（FIFO）なら非ゼロ |
  | S_ISSOCK | UNIXソケットなら非ゼロ           |
  |----------+----------------------------------|

*** パーミッションを表す定数
- 
  |-------------------+-------+--------------------------|
  | 定数              |    値 | 意味                     |
  |-------------------+-------+--------------------------|
  | S_IRUSR, S_IREAD  | 00400 | 所有ユーザから読込可能   |
  | S_IWUSR, S_IWRITE | 00200 | 所有ユーザから書込可能   |
  | S_IXUSR, S_IEXEC  | 00100 | 所有ユーザから実行可能   |
  | S_IRGRP           | 00040 | 所有グループから読込可能 |
  | S_IWGRP           | 00020 | 所有グループから書込可能 |
  | S_IXGRP           | 00010 | 所有グループから実行可能 |
  | S_IROTH           | 00010 | 所有グループから実行可能 |
  | S_IWOTH           | 00010 | 所有グループから実行可能 |
  | S_IXOTH           | 00010 | 所有グループから実行可能 |
  |-------------------+-------+--------------------------|

*** リダイレクト
- 
  標準入力が0, 標準出力は1, 標準エラー出力は2。

  標準出力サンプル。以下2つは同じ意味。
    echo Hello 1> hoge.txt
    echo Hello  > hoge.txt

  標準入力サンプル。以下2つも同じ意味。
    read fuga 0< hoge.txt
    read fuga  < hoge.txt

  標準エラー出力を標準出力にマージ
    some_command > hoge.txt 2>&1

*** コマンドの終了ステータス
- $?
  "$?"で直前の終了ステータスを取得できる。

- PIPESTATUS[]
  パイプライン内の任意の位置の終了ステータスを拾いたい場合、
  PIPESTATUSという環境変数を利用する。
  配列で、添え字は0始まり。
    ex) echo ${PIPESTATUS[0]}

*** 終了ステータス
- 
  0は成功、1はエラーというのは、Linux(UNIX)の決まりごと。
  成功・失敗のどちらかを表現するだけでよければ、
  EXIT_SUCCESSとEXIT_FAILUREというマクロを使うとよい。
  細かくステータスを分けたい場合、直接数値を書くべき。

*** 色属性のエスケープシーケンス
- ESC[色属性m
  上記のように書くことで、色属性が変更される。
  ESCはエスケープ文字だが、「\e」か「\033」もしくはESC制御文字(16進で"1b")を入力する。
  属性をリセットしデフォルトにするには、「ESC[0m」もしくは「ESC[m」とする。

- カラーコード
  カラーコード"31"の1文字目"3"は文字色指定を表す。
  また、"4"は背景色指定を表す。
  2文字目がカラーコードとなる。
  
  |------+---------|
  | 数字 | 色      |
  |------+---------|
  |    0 | Black   |
  |    1 | Red     |
  |    2 | Green   |
  |    3 | Yellow  |
  |    4 | Blue    |
  |    5 | Magenta |
  |    6 | Cyan    |
  |    7 | White   |
  |------+---------|

- 付加属性
  
  |----------+----------------+--------|
  | 属性番号 | attributes     | 属性   |
  |----------+----------------+--------|
  |        1 | bold           | 太字   |
  |        2 | low intensity  | 弱強調 |
  |        4 | underline      | 下線   |
  |        5 | blink          | 点滅   |
  |        7 | reverse video  | 反転   |
  |        8 | invisible text | 非表示 |
  |----------+----------------+--------|

- 例
  echo -e "\e[33;41;1mhoge\e[m"

- リンク
  [[http://www.m-bsys.com/linux/echo-color-1][シェル - echo で文字に色をつける その1]]
 
*** プロセス置換
- 
  コマンドの出力結果をファイルとして扱う機能。
  <(command)という形で使う。
    ex) diff text.txt <(sed -e 's/hoge/HOGE HOGE/' text.txt)

*** アドレス空間の確認
- 
  プロセスIDがｎのメモリ配置を見たければ、
  /proc/n/mapsを確認すればよい。
  
  pはprivateな領域、sはshared（共有）領域を表す。

*** zombie
- 
  fork()した後wait()しない場合に残っている状態。
  子が死んでも、親がwaitするときに備えてプロセス管理テーブル内の子エントリを開放せずに残しておくため、
  waitをしないといつまでも子エントリが残り続ける。
  ゾンビはリソースを開放しない上にシグナルは無視される。
  親プロセスがwaitせずに終了してしまった場合、initプロセスが自分の養子として引き受ける。
  psコマンドには"zombie"とか"defunct"と表示される。
  対策としては、1:forkしたらwait, 2:ダブルfork, 3:sigcation()を使う, などがある。

*** session
- 
  ユーザのログインからログアウトまでの流れを管理するための概念。
  ログインシェルを基点に、ユーザが同じ端末から起動したプロセスを1つにまとめる働きがある。
  結果プロセスグループをまとめるような形になる。
  最初にセッションを作ったプロセスがセッションリーダーで、
  psコマンド等で確認するとPID(プロセスID)とSID(セッションID)が等しい。
  リーダーは新しいセッションやプロセスを作れない。
  セッションと関連付けられた端末を、プロセスの制御端末(controlling terminal)という。

*** process group
- 
  パイプでつなげたプロセス群全てに処理の中断を行ってもらいたい、など、
  ある程度まとまった単位にシグナルを送れるように遅れるようにしたもの。
  最初にプロセスグループを作ったプロセスがプロセスグループリーダーで、
  psコマンド等で確認するとPID(プロセスID)とPGID(プロセスグループID)が等しい。

*** daemon
- 
  制御端末を持たないプロセスをdeamon processという。
  "ps ax"などで確認すると、ttyが"?"となっている。
  
*** 他のプロセスのカレントディレクトリ
- 
  自プロセス以外のカレントディレクトリは変更できない。
  知るだけなら/proc/プロセスID/cwdで確認可能。

*** environment variable
- 重要な環境変数
  |---------+-----------------------------------------------------|
  | 名前    | 意味                                                |
  |---------+-----------------------------------------------------|
  | PATH    | コマンドの存在するディレクトリ                      |
  | TERM    | 使っている端末の種類                                |
  | LANG    | ユーザのデフォルトロケール。                        |
  | LOGNAME | ユーザのログイン名                                  |
  | TEMP    | 一時ファイルを置くディレクトリ。/tmpなど。          |
  | PAGER   | manなどで起動するテキスト閲覧プログラム。lessなど。 |
  | EDITOR  | デフォルトエディタ。viやemacsなど                   |
  | MANPATH | manのソースをおいてあるディレクトリ                 |
  | DISPLAY | X Window Systemのデフォルトディスプレイ             |
  |---------+-----------------------------------------------------|

- environ
  グローバル関数environを介して環境変数にアクセスできる。
  型はchar**で、どのヘッダファイルでも宣言されていないので、
  自分で直接extern宣言をする必要がある。
  environの指す先は移動することがあるので、変数に保存しあとで使う等してはいけない。
  ex) extern char **environ;
*** ユーザ時間、システム時間
- システム時間
  そのプロセスのためにカーネルが働いた時間のこと。
- ユーザ時間
  システム時間以外の、プロセスが完全に自分で消費した時間のこと。

*** メジャーフォールト、マイナーフォールト
- メジャーフォールト major fal
  
- マイナーフォールト
*** UNIX epoch
- 
  Linuxカーネルは時刻を1970年1月1日からの経過秒数で保持している。
  この日時を俗に"UNIXエポック"と呼んでいる。
  1970年なのはUNIXの最初のバージョンがその頃に出来たため。
  Linuxカーネルでは常に協定世界時(UTC : Coordinated Universal Time)で計算している。

*** ログイン
- 
  ログインの流れ
  1. initが端末の数だけgettyコマンドを起動(/ect/linittabに設定値)
  2. 端末からのユーザ名入力を待ち、loginコマンドを起動
     gettyは端末をopen()し、read()して、ユーザ名がタイプされるのを待つ。
     端末の細かい設定などが必要なので、gettyという独立プログラムが必要。
     ユーザ名が入力されたら、dup()を使って0, 1, 2番につなぎ、loginをexecする。
  3. loginコマンドがユーザ認証
     ユーザデータベースのある場所等の差異は、/etc/nsswitch.confの設定にある。
     パスワードはPAMがあればそこで吸収、導入されていなければloginコマンドで意識する必要あり。
     伝統的には/etc/login.defsで設定していた。
  4. シェルを起動
     execするときにコマンドの頭に「-」をつけて起動数rと、ログインシェルとなり、動作が少し変わる。
     例）execl("/bin/sh", "-sh", ....);

*** PAM
- 
  Pluggable Authentication Module。
  実態は共有ライブラリだが、柔軟に対応できるようダイナミックロードを使ってライブラリを分割している。
  ライブラリは/lib/security。

