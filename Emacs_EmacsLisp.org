* Emacs-Lisp

** memo
キーマップ
    どのモードでも共通のキーマップはグローバルマップに、モード固有の設定はローカルマップに設定。
インタラクティブ関数
    ex: (interactive "sInput a:\nsInput b:)
        ↑"\n"までが一文で、プロンプトとして出力される。
         一文字目のsが文字列を引数として取ることを表している。

** command
C-x C-e
    直前の括弧のS式を評価
M-C-x
    現在の括弧のS式を評価
C-U M-C-x
    Edebug

M-:
    eval-expression
C-x M-:
    repeat-complex-command    
M-x
    describe-bindings
        キーバインド一覧
    describe-key
        特定のキー
    describe-function
        関数の説明

M-C-q
    インデントを直す(lisp-intreaction)

** function

predicate
    yes-or-no, true-or-falseで返す関数には、
    predicateの頭を取ってfunctionpやfunction-pなどとすることが多い。

defun
    関数定義
    (defun 関数名 (引数リスト *&optional, &rest)
       "説明文章"
       定義本体)
progn
    複数の処理をまとめる
setq
    値の設定
make-sparse-keymap
    空のキーマップを作成
    ex: (setq my-local-map (make-sparse-keymap))
define-key
    キーマップを割り当てる
    (define-key my-local-map "h" 'backward-char)
symbol-function
    関数の定義を出力する。
    ex: (symbol-funcion 'function)
let, let*
     let*は直前の宣言部での値を代入可能。
     (let (変数リスト)
        本体)
if
    (if 式 From1 Form2 ... Fromn)
    式がnil以外だった場合、From1を、nilだった場合はFrom2 ... Fromn までを実行する。
cond
    条件分岐をする際に用いる。
while
    while 式 本体
    ループ
progn,prog1,prog2,..
    式を順に評価していく。複数のS式を一つにまとめるためのもの。
    prognは最後の式を式を評価して返すが、prog1は一つ目の式、prog2は二つ目の式を返す。
catch, throw
    throwされた場合にcatch式の評価がその値でただちに行われ、catch式を抜ける。
unwind-protect
    途中で何らかの理由で終了した場合でも、最後まで処理をおこなってくれる関数。
    prog1の最後までやりきる版みたいなもの。評価値は最初の式。
error
    関数の評価をやめてコマンドループへ戻る。
    
*** 数値形変換関数
float, round(fround), floor(ffloor), ceiling(fceiling), truncate(ftruncate)
numberp, integerp, floatp

*** 一般算術関数
random, max, min
sin, cos, tan, asin, acos, atan, expt, sqrt
exp, log, logb, log10 (指数関数、対数関数:底e,2,10）
logand, logior, lognot, logxor（ビット演算:積、和、否定、排他的論理和）
lsh, ash（論理シフト、算術シフト）

*** 相互変換
string-to-number, string-to-char
char-to-string, number-to-string

format
    %s(文字列), %d(整数), %o(8進数), %x(16進数), %c(文字コードに対する文字),
    %f(浮動小数点数), %S(S式), %%(%自身)

*** 文字列操作
concat
substring
    (substring 文字列 開始位置 &optional 終了位置)
upcase, downcase
make-string
stringp, string=, string<

*** 便利
current-time-string
message
this-command-keys
sleep-for
sit-for
ding

*** 移動系
・移動系
bobp, eobp
    beginning(end) of buffer
bolp, eolp
    beginning(end) of line
forward-char, backward-char
    １文字前方（後方）に進める
forward-line, next-line
    forward-lineは次の行の先頭に、
    next-lineは次の行のできる限り同じカラムになるように動かす
forward-sexp, backward-sexp
    S式(S-expression)
    M-C-f, M-C-b
point
mark
region-beginning, region-end
point-min, point-max
goto-char
save-excursion
    処理から抜けると、処理開始位置に戻ってくる
goto-line
count-lines
move-to-window-line
    画面上の指定行に移動する。つまり画面上で何行目、という位置に飛ぶ。
beginning-of-line, end-of-line
move-to-column
    桁位置の移動。
current-column

・検索移動系
search-forward, search-backward
    (search-forward 文字列 &optional 限界 エラー回避 回数)
word-search-forward, word-search-backward
    単語単位の検索、例えば"TeX"を検索した場合"LaTeX"は含まれない。
match-beginning, match-end
    マッチした文字列の先頭（終端）のポイント位置を得ることができる。
    正規表現と合わせて利用した場合、グループ番号を指定することで
skip-chars-forward, skip-chars-backward
    (skip-chars-forward "文字列" &optional 限界)
    列挙した文字列群をスキップする。

*** 正規表現
・メタキャラクター
    .[]?*+^$\
・\表現
    \(\), \|, \数字, \<\>, \w \W, \sC \SC

・正規表現検索
re-search-forward(backward)
    (re-search-forward 正規表現 &optional 限界 エラー回避 回数)
    正規表現にマッチする文字列を順(逆)方向に検索する。
string-match
    (string-match 正規表現 文字列 &optional 開始位置)
    "文字列"中に"正規表現"にマッチする部分があるか照合する。
    マッチする部分があった場合マッチする位置を返す。なかったらnil。
looking-at
    (looking-at 正規表現)
    ポイント位置からの文字列が指定した正規表現にマッチするか照合する。
char-after, char-before
    (char-after &optional ポイント値)
    "ポイント値"で指定した位置の文字コードを返す。
following-char, preceding-char
    現在のポイント位置（ポイント位置の直前）の文字コードを返す。
    ポイント値を省略した場合のchar-after(before)と同様の動き。
match-string, match-string-no-properties
    直前の検索で見つかったグループ番号の文字列を返す。
buffer-substring, buffer-substring-no-properties
    (buffer-substring 開始 終了)
save-match-data
    (save-match-data 本体)
    match-dataの内容を保存して"本体"を評価した後で、match-dataの内容を復帰する。

*** 編集系
・削除
(kill-はkill-ringに値が設定されるため、基本的にはプログラム中で使わない。)
delete-char(delete-backward-char)
    (delete-char 文字数 &optional killフラグ)
delete-region
    (delete-region 開始位置 終了位置)
kill-region
kill-line
erase-buffer
・挿入
insert-char
    (insert-char 文字 個数)
    "文字"を"個数"だけ挿入する。
self-insert-command
    押したキーそのものを挿入する。個数指定必要。
・置換
replace-match
    (replace-match 新文字列 &optional 大文字小文字固定 リテラル) 
    直前の検索関数でマッチした部分全体を新しい文字列に置き換える。

** 変数
auto-mode-alistモードと拡張子の組、拡張子によって自動でモードを設定する。

major-mode
    メジャーモードの名前
mode-name
    モードラインに現れるモード名

global-map
    グローバルマップ
use-local-map
    ローカルマップ

?a
    aの文字コード
?\12, ?\x12
    8進数、16進数表記の整数
#NNr
    NN進数
    ex: #5r40→20, #30remacs→11943388

*** debug
    debug-on-error
    tになっている場合、backtraceを取得する。
    
